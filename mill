#!/usr/bin/ribosome

#
# Copyright (c) 2014 Martin Sustrik  All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

require "clexer"

./!loadxml
$name = input[0..-6]

vars = []

./!output $name + ".h"
.
./*  @{Time.now}:
.    This file was generated from @{input} */
.

.#ifndef @{$name.upcase}_H_INCLUDED
.#define @{$name.upcase}_H_INCLUDED
.
.struct @{$name} {
.    int ____state;
root.elements.each("arg") do |a|
.    @{a.attributes["type"]} @{a.attributes["name"]};
    vars << a.attributes["name"]
end
root.elements.each("var") do |v|
.    @{v.attributes["type"]} @{v.attributes["name"]};
    vars << v.attributes["name"]
end
.};
.
.void @{$name}_init(struct @{$name} *self
root.elements.each("arg") do |a|
.    /+, @{a.attributes["type"]} @{a.attributes["name"]}
end
.    /+);
.void @{$name}_handle(struct @{$name} *self, int src, int event);
.
.#endif
.
./!output $name + ".c"
.
./*  @{Time.now}:
.    This file was generated from @{input} */
.
.#include "@{$name}.h"
.
.#include <assert.h>
.
.#define ____EXPECT(s)\
.    self->____state = s;\
.    return;\
.    ____state##s:\
.    switch (src * 1000 + event)
.
.#define ____EVENT(obj, ev)\
.    case 1
.
.#define ____UNEXPECTED\
.    default:\
.        assert (0);

body = root.texts.join.to_s
ids = scan(body)
state = 1
offset = 0
for it in ids
    id = body[it[0]+offset..it[1]+offset]
    re = nil
    if(id.index('$') != nil)
        els = id.split('$')
        re = "____EVENT(" + els[0] + ", " + els[1] + ")"
    elsif(id == "expect")
        re = "____EXPECT(#{state})"
        it << state
        state += 1
    elsif(id == "unexpected")
        re = "____UNEXPECTED"
    elsif(vars.include?(id))
        re = "(self->#{id})"
    end
    if(re != nil)
        body[it[0]+offset..it[1]+offset] = re
        offset += re.size - (it[1] - it [0] + 1)
    end
end

.
.void @{$name}_init(struct @{$name} *self
root.elements.each("arg") do |a|
.    /+, @{a.attributes["type"]} @{a.attributes["name"]}
end
.    /+) {
.    self->____state = 0;
root.elements.each("arg") do |a|
.    self->@{a.attributes["name"]} = @{a.attributes["name"]};
end
.    @{$name}_handle(self, -1, -1);
.}
.
.void @{$name}_handle(struct @{$name} *self, int src, int event) {
.    switch (self->____state) {
.    case 0:
.        break;
for it in ids
    if(it.size == 3)
.    case @{it[2]}:
.        goto ____state@{it[2]};
    end
end
.    default:
.        assert(0);
.    }
.
.    @{body}
.}
.
