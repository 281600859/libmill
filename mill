#!/usr/bin/ribosome

#
# Copyright (c) 2014 Martin Sustrik  All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

require "clexer"

./!loadxml
$name = input[0..-6]

# Replace specific token in the text by a different text.
def replace(text, tokens, index, newtext)
    text[tokens[index][0]..tokens[index][1]] = newtext
    offset = newtext.size - (tokens[index][1] - tokens[index][0] + 1)
    for i in index + 1..tokens.size - 1
        tokens[i][0] += offset
        tokens[i][1] += offset
    end
end

# Find the matching bracket in the list of tokens.
def matchingb(tokens, index)
     startb = "("
     endb = ")"
     if(tokens[index][2] == "{")
         startb = "{"
         endb = "}"
     end
     count = 1
     for i in index + 1..tokens.size - 1
         count += 1 if tokens[i][2] == startb
         count -= 1 if tokens[i][2] == endb
         return i if count == 0
     end
     puts("can't find matching bracket\n")
     exit
end

vars = []

./!output $name + ".h"
.
./*  @{Time.now}:
.    This file was generated from @{input} */
.

.#ifndef @{$name.upcase}_H_INCLUDED
.#define @{$name.upcase}_H_INCLUDED
.
.struct @{$name} {
.    int ____state;
root.elements.each("arg") do |a|
.    @{a.attributes["type"]} @{a.attributes["name"]};
    vars << a.attributes["name"]
end
root.elements.each("var") do |v|
.    @{v.attributes["type"]} @{v.attributes["name"]};
    vars << v.attributes["name"]
end
.};
.
.void @{$name}_init(struct @{$name} *self
root.elements.each("arg") do |a|
.    /+, @{a.attributes["type"]} @{a.attributes["name"]}
end
.    /+);
.void @{$name}_handle(struct @{$name} *self, int src, int event);
.
.#endif
.
./!output $name + ".c"
.
./*  @{Time.now}:
.    This file was generated from @{input} */
.
.#include "@{$name}.h"
.
.#include <assert.h>
.
.#define ____EXPECT(s)\
.    self->____state = s;\
.    return;\
.    ____state##s:\
.    switch (src * 1000 + event) {
.
.#define ____EVENT(obj, ev)\
.    case 1
.
.#define ____ENDEXPECT\
.    default:\
.        assert (0);\
.    }

body = root.texts.join.to_s
tokens = scan(body)
state = 1
offset = 0
for i in 0..tokens.size - 1
    token = tokens[i][2]
    if(token.index('$') != nil)
        els = token.split('$')
        re = "____EVENT(" + els[0] + ", " + els[1] + ")"
        replace(body, tokens, i, re)
    elsif(token == "expect")
        re = "____EXPECT(#{state})"
        tokens[i] << state
        state += 1
        replace(body, tokens, i, re)
        if (tokens[i + 1][2] != "{")
            puts "expect should be followed by '{'"
            exit
        end
        replace(body, tokens, i + 1, "")
        im = matchingb(tokens, i + 1)
        replace(body, tokens, im, "____ENDEXPECT")
    elsif(vars.include?(token))
        re = "(self->#{token})"
        replace(body, tokens, i, re)
    end
end

.
.void @{$name}_init(struct @{$name} *self
root.elements.each("arg") do |a|
.    /+, @{a.attributes["type"]} @{a.attributes["name"]}
end
.    /+) {
.    self->____state = 0;
root.elements.each("arg") do |a|
.    self->@{a.attributes["name"]} = @{a.attributes["name"]};
end
.    @{$name}_handle(self, -1, -1);
.}
.
.void @{$name}_handle(struct @{$name} *self, int src, int event) {
.    switch (self->____state) {
.    case 0:
.        break;
for it in tokens
    if(it.size == 4)
.    case @{it[3]}:
.        goto ____state@{it[3]};
    end
end
.    default:
.        assert(0);
.    }
.
.    @{body}
.}
.
