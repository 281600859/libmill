#!/usr/bin/ribosome

#
# Copyright (c) 2014 Martin Sustrik  All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

require "clexer"

if input.size < 6 || input[-5..-1] != ".mill"
    $stderr.write "The input file must be a mill file.\n"
    exit
end
base_filename = input[0..-6]

################################################################################
# Tokenise the input file.                                                     #
################################################################################

text = IO.read(input)
tokens = parse(text)
i = 0
sections = []

################################################################################
#  Process includes.                                                           #
################################################################################

begin

    # Parse the includes section.
    for i in 0..tokens.size - 1
        break if tokens[i][0] != :include
    end
    includes_end = i == tokens.size ? text.size : tokens[i][1] 
    sections << [:includes, text[0..includes_end - 1]]

    # Make sure there are no more includes in the rest of the file.
    def no_includes(token)
        if token[0] == :include
            $stderr.write "All includes must be in the beginning of the file.\n"
            exit
        end
        if [:braces, :cbraces, :sbraces].include? token[0]
            no_includes token[3]
        end
    end
    for j in i..tokens.size - 1
        no_includes tokens[j]
    end
end

################################################################################
# Parse all coroutines.                                                        #
################################################################################

begin

    loop do

        # Find the start of next coroutine.
        # Treat anything that precedes it as raw C code.
        start = i
        while ![:coroutine, :end].include? tokens[i][0]
            i += 1;
        end
        stop = i
        if tokens[i][0] == :coroutine
            while stop > start
                break if [:cbraces, :semicolon].include? tokens[stop - 1][0]
                stop -= 1
            end
        end
        sections << [:c, text[tokens[start][1]..tokens[stop][1] - 1]]

        # End of file.
        break if tokens[i][0] == :end

        # Parse the coroutine itself.
        # First get the result type.
        type = text[tokens[stop][1]..tokens[i - 1][2]]
            
        # Coroutine name.
        i += 1
        if tokens[i][0] != :identifier
            $stderr.write "Coroutine name missing.\n"
            exit
        end
        name = text[tokens[i][1]..tokens[i][2]]

        # Coroutine argument list.
        i += 1
        if tokens[i][0] != :braces
            $stderr.write "Coroutine argument list missing.\n"
            exit
        end
        args = []
        argtokens = tokens[i][3]
        start = 0
        for k in 0..argtokens.size - 1
            break if argtokens[k][0] == :end && k == start
            if [:comma, :end].include? argtokens[k][0]
                if argtokens[k - 1][0] != :identifier
                    $stderr.write "Invalid coroutine argument.\n"
                    exit
                end
                argname = text[argtokens[k - 1][1]..argtokens[k - 1][2]]
                argtype = text[argtokens[start][1]..argtokens[k - 2][2]]
                args << {:name => argname, :type => argtype}
                start = k + 1
            end
        end

        # Coroutine body.
        i += 1
        if tokens[i][0] != :cbraces
            $stderr.write "Coroutine body missing.\n"
            exit
        end
        bodytokens = tokens[i][3]

        # Split the body into variable declarations and executable part.
        vartokens = []
        for j in 0..bodytokens.size - 1
            break if bodytokens[j][0] == :end
            if bodytokens[j][0] == :endvars
                if bodytokens[j + 1][0] != :semicolon
                   $stderr.write "'endvars' must be followed by a semicolon.\n"
                   exit
                end
                vartokens = bodytokens[0..j - 1]
                bodytokens = bodytokens[j + 2..-1]
                break
            end
        end
        #vartokens << [:end, bodytokens[0][1] - 1, bodytokens[0][1] - 1]

        # Local variables.
        vars = []
        start = 0
        for j in 0..vartokens.size - 1
           if vartokens[j][0] == :end
               break if start == j
               $stderr.write "Invalid tokens following variable declaration.\n"
               exit
           end
           if vartokens[j][0] == :semicolon
               if vartokens[j - 1][0] != :identifier
                   $stderr.write "Invalid variable declaration.\n"
                   exit
               end
               varname = text[vartokens[j - 1][1]..vartokens[j - 1][2]]
               vartype = text[vartokens[start][1]..vartokens[j - 2][2]]
               vars << {:name => varname, :type => vartype}
               start = j + 1
           end
        end

        # Store the executable part of the coroutine
        # along with the corresponding tokens.
        body = text[bodytokens[0][1]..bodytokens[-1][1]]
        offset = bodytokens[0][1];
        for t in bodytokens
            t[1] -= offset
            t[2] -= offset
        end
         
        # Create a coroutine section.
        sections << [:coroutine, {
            :name => name,
            :type => type,
            :args => args,
            :vars => vars,
            :body => body,
            :tokens => bodytokens
        }]

        i += 1
    end

end

# We won't need the original source code anymore. Let's garbage-collect it!
text = nil
tokens = nil

################################################################################
# Transformations within coroutine body.                                       #
################################################################################

begin

    # Replace specific token in the text by a different text.
    def replace(text, tokens, index, newtext)
        text[tokens[index][1]..tokens[index][2]] = newtext
        offset = newtext.size - (tokens[index][2] - tokens[index][1] + 1)
        for i in index + 1..tokens.size - 1
            tokens[i][1] += offset
            tokens[i][2] += offset
        end
    end

    for s in sections
        if s[0] == :coroutine
            c = s[1]
            body = c[:body]
            tokens = c[:tokens]
            state = 0
            for i in 0..tokens.size - 1

                if tokens[i][0] == :getevent
                    for j in i + 1..tokens.size - 1
                        break if [:semicolon, :end].include? tokens[j][0]
                    end
                    if tokens[j][0] != :semicolon
                        $stderr.write "'getevent' statement should be terminated by semicolon.\n"
                        exit
                    end
                    state += 1
                    replace(body, tokens, i, "____getevent(#{state}, ")
                    replace(body, tokens, j, ");")
                end

                if tokens[i][0] == :return
                    for j in i + 1..tokens.size - 1
                        break if [:semicolon, :end].include? tokens[j][0]
                    end
                    if tokens[j][0] != :semicolon
                        $stderr.write "'return' statement should be terminated by semicolon.\n"
                        exit
                    end
                    replace(body, tokens, i, "____return(");
                    replace(body, tokens, j, ");")
                end

            end
            c[:laststate] = state

        end
    end

end

################################################################################
# Generate the .h file.                                                        #
################################################################################

./!output base_filename + ".h"

./* @{Time.now}:
.   This file was generated from @{input} */
.
.#include "mill.h"
.
# Includes.
.@{sections[0][1]}
.
for s in sections
    if s[0] == :coroutine
        c = s[1]
.struct ____coroutine_@{c[:name]} {
.    struct ____base ____base;
if c[:type] != "void"
.    @{c[:type]} ____result;
end
for a in c[:args]
.    @{a[:type]} @{a[:name]};
end
for v in c[:vars]
.    @{v[:type]} @{v[:name]};
end
.};
.
    end
end

################################################################################
# Generate the .c file.                                                        #
################################################################################

./!output base_filename + ".c"

./* @{Time.now}:
.   This file was generated from @{input} */
.
.#include "@{base_filename}.h"
.
for s in sections
    if s[0] == :c
.@{s[1]}
.
    elsif s[0] == :coroutine
        c = s[1]
.static void @{c[:name]}_handler(____base *base, event ev)
.{
.    struct ____coroutine_@{c[:name]} *self = (struct ____coroutine_@{c[:name]}*) base;
.
.    switch (self->____base.state) {
.    case 0:
.        break;
for i in 1..c[:laststate]
.    case @{i}:
.        goto state@{i}:
end
.    default:
.        assert (0);
.    }
.
.    @{c[:body]}
.}
.
    end
end

