#!/usr/bin/ribosome

#
# Copyright (c) 2014 Martin Sustrik  All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

require "clexer"

if input.size < 6 || input[-5..-1] != ".mill"
    $stderr.write "The input file must be a mill file."
    exit
end
$name = input[0..-6]

################################################################################
# Helper functions. #
################################################################################

# Replace specific token in the text by a different text.
def replace(text, tokens, index, newtext)
    text[tokens[index][0]..tokens[index][1]] = newtext
    offset = newtext.size - (tokens[index][1] - tokens[index][0] + 1)
    for i in index + 1..tokens.size - 1
        tokens[i][0] += offset
        tokens[i][1] += offset
    end
end

################################################################################
#  Split the text into several sections.                                       #
################################################################################

prologue = nil
args = nil
vars = nil
body = nil
cleanup = nil
epilogue = nil

begin
    text = IO.read(input)
    tree = parse(:phase1, text)
    prologue_start = 0
    prologue_stop = -2
    for i in 0..tree.size - 1
        if tree[i][0] == :coroutine
            prologue_stop = tree[i][1] - 1
            break
        end
    end
    if prologue_stop == -2
        puts "No coroutine found in the source file.\n"
        exit
    end
    if tree[i + 1][0] != :braces
        $stderr.write "Coroutine keyword must by followed by a list of arguments.\n"
        exit
    end
    args_start = tree[i + 1][1] + 1
    args_stop = tree[i + 1][2] - 1
    if tree[i + 2][0] != :cbraces
        $stderr.write "Coroutine argument list must by followed by a function body.\n"
        exit
    end
    vars_start = tree[i + 2][1] + 1
    cleanup_stop = tree[i + 2][2] - 1
    epilogue_start = tree[i + 2][2] + 1
    epilogue_stop = text.size
    btree = tree [i + 2][3]
    vars_stop = -2
    for j in 0..btree.size - 1
        if btree[j][0] == :body
            if btree[j + 1][0] != :colon
                $stderr.write "Body keyword must by followed by a colon.\n"
                exit
            end
            vars_stop = btree[j][1] - 1
            body_start = btree[j + 1][2] + 1
            break
        end
    end
    if vars_stop == -2
        vars_stop = vars_start
        body_start = vars_start
    end
    body_stop = -2
    for k in j + 2..btree.size - 1
        if btree[k][0] == :cleanup
            if btree[k + 1][0] != :colon
                $stderr.write "Cleanup keyword must by followed by a colon.\n"
                exit
            end
            body_stop = btree[k][1] - 1
            cleanup_start = btree[k + 1][2] + 1
            break
        end
    end
    if body_stop == -2
        body_stop = cleanup_stop
        cleanup_start = cleanup_stop
    end

    prologue = text[prologue_start..prologue_stop]
    args = text[args_start..args_stop]
    vars = text[vars_start..vars_stop]
    body = text[body_start..body_stop]
    cleanup = text[cleanup_start..cleanup_stop]
    epilogue = text[epilogue_start..epilogue_stop]
end

################################################################################
# Process the mill includes.                                                   #
################################################################################

$includes = []
begin
    def process_includes(text)
        incls = parse(:phase2, text)
        for i in 0..incls.size - 1
            if incls[i][2].size >= 5 && incls[i][2][-5..-1] == ".mill"
                replace(text, incls, i, incls[i][2][0..-6] + ".h")
                $includes << incls[i][2][0..-6]
            end
        end
    end
    process_includes(prologue)
    process_includes(epilogue)
end

################################################################################
# Process the coroutine arguments.                                             #
################################################################################

$locals = []
$localdecls = ""
begin
    tokens = parse(:phase3, args + ",")
    start = 0
    for i in 0..tokens.size - 1
        if tokens[i][2] == :comma
            if i == 0 || tokens[i - 1][2] != :identifier
                $stderr.write "Malformed coroutine argument list.\n"
                exit
            end
            $locals << tokens[i - 1][3]
            $localdecls += args[start..tokens[i - 1][1]].strip
            $localdecls += ";\n"
            start = tokens[i][1] + 1
        end
    end
end

################################################################################
# Process the coroutine local variables.                                       #
################################################################################

begin
    tokens = parse(:phase4, vars)
    start = 0
    for i in 0..tokens.size - 1
        if tokens[i][2] == :semicolon
            if i == 0 || tokens[i - 1][2] != :identifier
                $stderr.write "Malformed coroutine local variable list.\n"
                exit
            end
            $locals << tokens[i - 1][3]
            $localdecls += vars[start..tokens[i - 1][1]].strip
            $localdecls += ";\n"
            start = tokens[i][1] + 1
        end
    end
end

################################################################################
# Expand local variables in the coroutine body.                                #
################################################################################

$states = []
begin
    def process_locals(text, body)
        tokens = parse(:phase5, text)
        state = 1
        for i in 0..tokens.size - 1
            if body && tokens[i][3] == "getevent"
                if (tokens[i + 1][2] != :lbrace)
                    $stderr.write  "Getevent function must be followed by argument list.\n"
                    exit
                end
                replace(text, tokens, i, "MILL_GETEVENT")
                replace(text, tokens, i + 1, "(#{state}, ")
                $states << state
                state += 1
            elsif body && tokens[i][3] == "return"
                replace(text, tokens, i, "goto mill_shutdown_state_0")
            elsif $locals.include? tokens[i][3]
                replace(text, tokens, i, "(self->#{tokens[i][3]})")
            end
        end
    end
    process_locals(body, true)
    process_locals(cleanup, false)
end

################################################################################
# Generate the header file.                                                    #
################################################################################

./!output $name + ".h"

./* @{Time.now}:
.   This file was generated from @{input} */
.
.void *@{$name} ();
.

################################################################################
# Generate the C file.                                                         #
################################################################################

./!output $name + ".c"

./* @{Time.now}:
.   This file was generated from @{input} */
.
.#include "@{$name}.h"
.#include "mill.h"
.
.@{prologue}
.
.struct @{$name} {
.    struct mill_ctx mill_ctx;
.    @{$localdecls}
.};
.
.void *@{$name}() {
.
.    switch (ctx->mill_ctx.state) {
.    case 0:
.        break;
for state in $states
.    case @{state}:
.        goto mill_state_@{state};
end
.    default:
.        assert(0);
.    }
.
.    @{body}
.
.mill_shutdown_state_0:
.    @{cleanup}
.    return 0;
.}
.
.@{epilogue}
.

