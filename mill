#!/usr/bin/ribosome

#
# Copyright (c) 2014 Martin Sustrik  All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

require "clexer"

if input.size < 6 || input[-5..-1] != ".mill"
    $stderr.write "The input file must be a mill file.\n"
    exit
end
base_filename = input[0..-6]

################################################################################
# Debug helpers.                                                               #
################################################################################

def dump(text, tokens)
    for t in tokens
        puts "#{t[0]}, #{t[1]}, #{t[2]}, \"#{text[t[1]..t[2]]}\""
        if t[3] != nil
            dump(text, t[3])
        end
    end
end

################################################################################
# Tokenise the input file.                                                     #
################################################################################

text = IO.read(input)
tokens = parse(text)
i = 0
sections = []

################################################################################
#  Process includes.                                                           #
################################################################################

begin

    # Parse the includes section.
    for i in 0..tokens.size - 1
        break if tokens[i][0] != :include
    end
    includes_end = i == tokens.size ? text.size : tokens[i][1] 
    sections << [:includes, text[0..includes_end - 1]]

    # Make sure there are no more includes in the rest of the file.
    def no_includes(token)
        if token[0] == :include
            $stderr.write "All includes must be in the beginning of the file.\n"
            exit
        end
        if [:braces, :cbraces, :sbraces].include? token[0]
            no_includes token[3]
        end
    end
    for j in i..tokens.size - 1
        no_includes tokens[j]
    end
end

################################################################################
# Parse all coroutines.                                                        #
################################################################################

# Shift positions of all tokens past the position start by offset.
def apply_offset(tokens, start, offset)
    for t in tokens
        t[1] += offset if t[1] > start
        t[2] += offset if t[2] > start
        if t[3] != nil
            apply_offset(t[3], start, offset)
        end
    end
end

begin

    # Make typestring from a list of tokens.
    def make_type(text, tokens)
        type = ""
        last = tokens[0][1]
        for k in 0..tokens.size - 1
            if tokens[k][0] == :coroutine
                type += text[last..tokens[k][1] - 1]
                type += "struct ____coroutine_#{text[tokens[k+1][1]..tokens[k+1][2]]}"
                last = tokens[k + 1][2] + 1
            end
        end
        type += text[last..tokens[-1][2]]
        return type
    end

    loop do

        # Find the start of next coroutine.
        # Treat anything that precedes it as raw C code.
        start = i
        while ![:coroutine, :end].include? tokens[i][0]
            i += 1;
        end
        stop = i
        if tokens[i][0] == :coroutine
            while stop > start
                break if [:cbraces, :semicolon].include? tokens[stop - 1][0]
                stop -= 1
            end
        end
        sections << [:c, text[tokens[start][1]..tokens[stop][1] - 1]]

        # End of file.
        break if tokens[i][0] == :end

        # Parse the coroutine itself.
        # First get the result type.
        type = text[tokens[stop][1]..tokens[i - 1][2]]
            
        # Coroutine name.
        i += 1
        if tokens[i][0] != :identifier
            $stderr.write "Coroutine name missing.\n"
            exit
        end
        name = text[tokens[i][1]..tokens[i][2]]

        # Coroutine argument list.
        i += 1
        if tokens[i][0] != :braces
            $stderr.write "Coroutine argument list missing.\n"
            exit
        end
        args = []
        locals = []
        argtokens = tokens[i][3]
        start = 0
        for k in 0..argtokens.size - 1
            break if argtokens[k][0] == :end && k == start
            if [:comma, :end].include? argtokens[k][0]
                if argtokens[k - 1][0] != :identifier
                    $stderr.write "Invalid coroutine argument.\n"
                    exit
                end
                argname = text[argtokens[k - 1][1]..argtokens[k - 1][2]]
                argtype = make_type(text, argtokens[start..k - 2])
                args << {:name => argname, :type => argtype}
                locals << argname
                start = k + 1
            end
        end

        # Coroutine body.
        i += 1
        if tokens[i][0] != :cbraces
            $stderr.write "Coroutine body missing.\n"
            exit
        end
        bodytokens = tokens[i][3]
        bodytokens.unshift [:whitespace, tokens [i][1] + 1, bodytokens[0][1] - 1]

        # Split the body into variable declarations and executable part.
        vartokens = []
        for j in 0..bodytokens.size - 1
            break if bodytokens[j][0] == :end
            if bodytokens[j][0] == :endvars
                if bodytokens[j + 1][0] != :semicolon
                   $stderr.write "'endvars' must be followed by a semicolon.\n"
                   exit
                end
                wsstart = bodytokens[j + 1][2] + 1
                vartokens = bodytokens[0..j - 1]
                bodytokens = bodytokens[j + 2..-1]
                bodytokens.unshift [:whitespace, wsstart, bodytokens[0][1] - 1]
                break
            end
        end
        vartokens << [:end, bodytokens[0][1] - 1, bodytokens[0][1] - 1]

        # Local variables.
        vars = []
        start = 1
        for j in 1..vartokens.size - 1
           if vartokens[j][0] == :end
               break if start == j
               $stderr.write "Invalid tokens following variable declaration.\n"
               exit
           end
           if vartokens[j][0] == :semicolon
               if vartokens[j - 1][0] != :identifier
                   $stderr.write "Invalid variable declaration.\n"
                   exit
               end
               varname = text[vartokens[j - 1][1]..vartokens[j - 1][2]]
               vartype = make_type(text, vartokens[start..j - 2])
               vars << {:name => varname, :type => vartype}
               locals << varname
               start = j + 1
           end
        end

        # Store the executable part of the coroutine
        # along with the corresponding tokens.
        body = text[bodytokens[0][1]..bodytokens[-1][1] - 1]
        apply_offset(bodytokens, 0, -bodytokens[0][1])
         
        # Create a coroutine section.
        sections << [:coroutine, {
            :name => name,
            :type => type,
            :args => args,
            :vars => vars,
            :locals => locals,
            :body => body,
            :tokens => bodytokens
        }]

        i += 1
    end

end

# We won't need the original source code anymore. Let's garbage-collect it!
text = nil
tokens = nil

################################################################################
# Transformations within coroutine body.                                       #
################################################################################

# Replace specific token in the text by a different text.
def replace(text, tokens, token, newtext)
    text[token[1]..token[2]] = newtext
    offset = newtext.size - (token[2] - token[1] + 1)
    apply_offset(tokens, token[1], offset)
end

begin

    for s in sections
        if s[0] == :coroutine
            c = s[1]
            body = c[:body]
            tokens = c[:tokens]

            # Expand local variables.
            def expand_vars(body, alltokens, tokens, locals)
                for i in 0..tokens.size - 1
                    if tokens[i][0] == :identifier && (i == 0 || tokens[i - 1][0] != :struct)
                        idname = body[tokens[i][1]..tokens[i][2]]
                        if locals.include? idname
                            replace(body, alltokens, tokens[i], "(self->#{idname})")
                        end
                    elsif [:braces, :cbraces, :sbraces].include? tokens[i][0]
                        expand_vars(body, alltokens, tokens[i][3], locals)
                    end
                end
            end
            expand_vars(body, tokens, tokens, c[:locals])

            # Expand mill keywords.
            def expand_keywords(body, alltokens, tokens, state)
                for i in 0..tokens.size - 1

                    if tokens[i][0] == :getevent
                        for j in i + 1..tokens.size - 1
                            break if [:semicolon, :end].include? tokens[j][0]
                        end
                        if tokens[j][0] != :semicolon
                            $stderr.write "'getevent' statement should be terminated by semicolon.\n"
                            exit
                        end
                        state += 1
                        replace(body, alltokens, tokens[i], "____getevent (#{state},")
                        replace(body, alltokens, tokens[j], ");")
                    end

                    if tokens[i][0] == :return
                        for j in i + 1..tokens.size - 1
                            break if [:semicolon, :end].include? tokens[j][0]
                        end
                        if tokens[j][0] != :semicolon
                            $stderr.write "'return' statement should be terminated by semicolon.\n"
                            exit
                        end
                        replace(body, alltokens, tokens[i], "____return (");
                        replace(body, alltokens, tokens[j], ");")
                    end

                    if tokens[i][0] == :call
                        if tokens[i + 1][0] != :identifier
                            $stderr.write "'call' statement should be terminated by coroutine name.\n"
                            exit
                        end
                        replace(body, alltokens, tokens[i], "____call_#{body[tokens[i + 1][1]..tokens[i+1][2]]}");
                        replace(body, alltokens, tokens[i + 1], "")
                    end

                    if tokens[i][3] != nil
                        state = expand_keywords(body, alltokens, tokens[i][3], state)
                    end

                end

                return state
            end
            c[:laststate] = expand_keywords(body, tokens, tokens, 0)

        end
    end

end

################################################################################
# Generate the .h file.                                                        #
################################################################################

./!output base_filename + ".h"

./* @{Time.now}:
.   This file was generated from @{input} */
.
.#include "mill.h"
.
# Includes.
.@{sections[0][1]}
.
for s in sections
    if s[0] == :coroutine
        c = s[1]
.struct ____coroutine_@{c[:name]} {
.    struct ____base ____base;
if c[:type] != "void"
.    @{c[:type]} ____result;
end
for a in c[:args]
.    @{a[:type]} @{a[:name]};
end
for v in c[:vars]
.    @{v[:type]} @{v[:name]};
end
.};
.
.void ____call_@{c[:name]} (struct ____coroutine_@{c[:name]} *self
for a in c[:args]
.    /+, @{a[:type]} @{a[:name]}
end
./+);
.
    end
end

################################################################################
# Generate the .c file.                                                        #
################################################################################

./!output base_filename + ".c"

./* @{Time.now}:
.   This file was generated from @{input} */
.
.#include "@{base_filename}.h"
.
for s in sections
    if s[0] == :c
.@{s[1]}
.
    elsif s[0] == :coroutine
        c = s[1]
.static void @{c[:name]}_handler(struct ____base *base, event ev)
.{
.    struct ____coroutine_@{c[:name]} *self = (struct ____coroutine_@{c[:name]}*) base;
.
.    switch (self->____base.state) {
.    case 0:
.        break;
for i in 1..c[:laststate]
.    case @{i}:
.        goto state@{i}:
end
.    default:
.        assert (0);
.    }
.
.    @{c[:body]}
.}
.
.void ____call_@{c[:name]} (struct ____coroutine_@{c[:name]} *self
for a in c[:args]
.    /+, @{a[:type]} @{a[:name]}
end
./+) {
.    ____base_init (&self->____base, @{c[:name]}_handler);
for a in c[:args]
.    self->@{a[:name]} = @{a[:name]};
end
.}
.
    end
end

