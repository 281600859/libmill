#!/usr/bin/ribosome

#
# Copyright (c) 2014 Martin Sustrik  All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom
# the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#

require "clexer"

./!loadyaml

################################################################################
#  Global variables.                                                           #
################################################################################

$name = input[0..-6]
$includes = []
$imports = []
$args = []
$vars = []
$states = []

################################################################################
#  Helper functions.                                                           #
################################################################################

# Replace specific token in the text by a different text.
def replace(text, tokens, index, newtext)
    text[tokens[index][0]..tokens[index][1]] = newtext
    offset = newtext.size - (tokens[index][1] - tokens[index][0] + 1)
    for i in index + 1..tokens.size - 1
        tokens[i][0] += offset
        tokens[i][1] += offset
    end
end

# Find the matching bracket in the list of tokens.
def matchingb(tokens, index)
     startb = "("
     endb = ")"
     if(tokens[index][2] == "{")
         startb = "{"
         endb = "}"
     end
     count = 1
     for i in index + 1..tokens.size - 1
         count += 1 if tokens[i][2] == startb
         count -= 1 if tokens[i][2] == endb
         return i if count == 0
     end
     puts("can't find matching bracket\n")
     exit
end

################################################################################
#  Preprocess the function body.                                               #
################################################################################

root["imports"] = [] if root["imports"] == nil
root["args"] = [] if root["args"] == nil
root["vars"] = [] if root["vars"] == nil

for i in root["imports"]
    $imports << i;
end
for a in root["args"]
    name = a.strip.split(/\s+/)[-1]
    $args << name;
    $vars << name;
end
for v in root["vars"]
    name = v.strip.split(/\s+/)[-1]
    $vars << name;
end

body = root["body"]
tokens = scan(body)
state = 1
for i in 0..tokens.size - 1
    token = tokens[i][2]
    if(token == "getevent")
        if (tokens[i + 1][2] != "(")
            puts "error: getevent should be followed by '('"
            exit
        end
        replace(body, tokens, i, "MILL_GETEVENT")
        replace(body, tokens, i + 1, "(#{state}, ")
        $states << state
        state += 1
    elsif(token == "return")
        replace(body, tokens, i, "goto mill_shutdown_state_0")
    elsif($vars.include?(token))
        replace(body, tokens, i, "(ctx->#{token})")
    elsif($imports.include?(token))
        replace(body, tokens, i, "MILL_INVOKE(#{token})")
    end
end

################################################################################
#  Generation of the header file.                                              #
################################################################################

./!output $name + ".h"
.
./*  @{Time.now}:
.    This file was generated from @{input} */
.

.#ifndef @{$name.upcase}_H_INCLUDED
.#define @{$name.upcase}_H_INCLUDED
.
.#include "mill.h"
for i in $imports
.#include "@{i}.h"
end
.
.struct @{$name}_ctx {
.    struct mill_ctx mill_ctx;
for a in root["args"]
.    @{a};
end
for v in root["vars"]
.    @{v};
end
.};
.
.void @{$name} (struct @{$name}_ctx *ctx
for a in root["args"]
.    /+, @{a}
end
.    /+);
.
.#endif
.

################################################################################
#  Generation of the source file.                                              #
################################################################################

./!output $name + ".c"
.
./*  @{Time.now}:
.    This file was generated from @{input} */
.
.#include "@{$name}.h"
.
.static void @{$name}_handler(struct mill_ctx *mctx, int src, int event) {
.
.    struct @{$name}_ctx *ctx = (struct @{$name}_ctx*) mctx;
.
.    switch (ctx->mill_ctx.state) {
.    case 0:
.        break;
for state in $states
.    case @{state}:
.        goto mill_state_@{state};
end
.    default:
.        assert(0);
.    }
.
.    @{body}
.
.mill_shutdown_state_0:
.    ;
.}
.
.void @{$name} (struct @{$name}_ctx *ctx
for a in root["args"]
.    /+, @{a}
end
.    /+) {
.    mill_ctx_init (&ctx->mill_ctx, @{$name}_handler);
for a in $args
.    ctx->@{a} = @{a};
end
.    @{$name}_handler (&ctx->mill_ctx, -1, -1);
.}
.
