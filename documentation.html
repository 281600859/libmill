<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>mill</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>

<img src="mill.png"/>

<p><b>Go-style concurrency in C</b></p>

<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="development.html">Development</a></li>
<li><a href="community.html">Community</a></li>
</ul>

<h2>Documentation</h2>

<ul id="toc">
  <li><a href="#build">Build</a></li>
  <li><a href="#coroutines">Coroutines</a></li>
  <li><a href="#channels">Channels</a></li>
  <li><a href="#choose">Choose statement</a></li>
  <li><a href="#library">Library</a></li>
  <li><a href="#cls">Coroutine-local storage</a></li>
  <li><a href="#performance">Performance considerations</a></li>
</ul>

<h3 id="build">Build</h3>

<p>To use Mill add <tt>mill.c</tt> to your project. Whichever files need
Mill's functionality should then include <tt>mill.h</tt> header file. </p>

<p>Mill works with x86-64, gcc and Linux. OSX requires a true gcc (for example,
from MacPorts or Homebrew) and not clang. Turn the optimiser off using
<tt>-O0</tt> option.</p>

<p>Whether it works in different environments is not known. Please, do report
any successes as well as failures on the mailing list.</p>

<h3 id="coroutines">Coroutines</h3>

<p>Any function can be executed as a coroutine using <tt>go</tt> keyword:</p>

<pre>
void foo(int i, int j) {
    ...
}

int main() {
    go(foo(1, 2));
    return 0;
}
</pre>

<p>Even functions with exotic argument lists can be executed as coroutines:</p>

<pre>
go(printf("%d + %d = %d\n", 2, 2, 4));
</pre>

<p>However, keep in mind that coroutines are executed asynchronously and thus,
even if the function returns a value, there is now way to retrieve it.</p>

<p>Also keep in mind that coroutines are scheduled in a cooperative fashion.
If one coroutine block, for example by calling <tt>sleep()</tt>, it blocks
the whole process. Therefore, coroutine-friendly versions of blocking functions
(such as <tt>mconnect()</tt> or <tt>msend()</tt>, see below) should be used.</p>

<p>In addition, you can yield CPU to other coroutines explicitly:</p>

<pre>
yield();
</pre>

<h3 id="channels">Channels</h3>

Channels are typed pipes used for communication between coroutines. To create
a channel you have to specify what kind of values are meant to be passed
through it. The second parameter is the buffer size. Setting this argument
to zero yields unbuffered channel:</p>

<pre>
chan ch = chmake(int, 0);
</pre>

<p>To send a value to the channel use <tt>chs</tt> construct. Note that
this is a statement, not a function returning a value. The type specified
as the second parameter must match the type of the channel otherwise you'll
get runtime exception.</p>

<pre>
chs(ch, int, 42);
</pre>

<p>To receive a value from the channel use <tt>chr</tt> expression. The type
specified as the second parameter must match the type of the channel otherwise
you'll get runtime exception.</p>

<pre>
int i = chr(ch, int);
</pre>

<p>To deallocate the channel use <tt>chclose</tt> function:</p>

<pre>
chclose(ch);
</pre>

<p>When sharing a channel between two or more coroutines you can duplicate
the channel handle. Channel is deallocated only after all its handles
are closed. For example:</p>

<pre>
void sender(chan ch) {
    chs(ch, int, 42);
    chclose(ch);
}

int main() {
    chan ch = chmake(int, 0);
    go(sender(chdup(ch)));
    int i = chr(ch, int);
    assert(i == 42);
    chclose(ch);
    return 0;
}
</pre>

<h3 id="choose">Choose statement</h3>

<p>Choose statement is equivalent to Go's <tt>select</tt> statement. It can be
used for waiting to send or receive data from multiple channels.</p>

<p>Within <tt>choose</tt> there's a list of clauses containing multiple
<tt>in</tt> and <tt>out</tt> statements and at most one <tt>otherwise</tt>
statement. Don't forget to add <tt>end</tt> statement before the closing
parenthesis.</p>

<p>Clause <tt>in</tt> causes <tt>choose</tt> to wait for a message coming
from channel <tt>ch</tt>. The clause declares variable <tt>var</tt> of type
<tt>type</tt> and stores the incoming message into it. If <tt>type</tt> doesn't
match the actual type of the channel you'll get a runtime exception.</p>

<pre>
in(ch, type, var):
</pre>

<p>Clause <tt>out</tt> causes <tt>choose</tt> to wait while value <tt>val</tt>
of type <tt>type</tt> can be sent to channel <tt>ch</tt>. Same way as with
</tt>in</tt>, if <tt>type</tt> doesn't match the actual type of channel
<tt>ch</tt> runtime exception is generated.</p>

<pre>
out(ch, type, val):
</pre>

<p>Clause <tt>otherwise</tt> is optional. It is executed only if no other
clauses can be matched immediately. Therefore, <tt>choose</tt> statement
with <tt>otherwise</tt> clause will never block.</p>

<pre>
choose {
in(ch1, int, val):
    printf("Value %d received from ch1.\n", val);
out(ch2, int, 42):
    printf("Value 42 sent to ch2.\n");
otherwise:
    printf("Neither ch1 nor ch2 can be used at the moment.\n");
end
}
</pre>

<p><tt>choose</tt> statement waits for the first available clause and executes
the code that follows it. If there are multiple clauses available
one of them is chosen at random.</p>

<p>There's no fall-through among the clauses.</p>

<h3 id="library">Library</h3>

<t>The library contains coroutine-friendly versions of system blocking
functions as well as some convenience stuff.</t>

<p>To sleep without blocking the entire process:</p>

<pre>
void msleep(unsigned long ms);
</pre>

<p>This function returns an int-type channel that will become available for
receiving after specified amount of time. Don't forget to close the channel
after using it.</p>

<pre>
chan after(unsigned long ms);
</pre>

<p>To deal with sockets use the following functions. Except for being
coroutine-friendly they behave exactly the same as their POSIX counterparts:</p>

<pre>
int msocket(int family, int type, int protocol);
int mconnect(int s, const struct sockaddr *addr, socklen_t addrlen);
int maccept(int s, struct sockaddr *addr, socklen_t *addrlen);
ssize_t msend(int s, const void *buf, size_t len, int flags);
ssize_t mrecv(int s, void *buf, size_t len, int flags);
</pre>

<h3 id="cls">Coroutine-local storage</h3>

<p>User can allocate coroutine-local data and attach it to the coroutine
using <tt>setcls</tt> function. For example:</p>

<pre>
struct mycls {
    int a;
    int b;
};

void *data = malloc(sizeof(struct mycls));
setcls(data);
</pre>

<p>Later on the data can be accessed anywhere within the coroutine using
<tt>cls</tt> function:</p>

<pre>
struct mycls *data = cls();
printf("CLS: a=%d b=%d\n", data->a, data->b);
</pre>

<p>It can be safely assumed that before coroutine-local data are set,
<tt>cls</tt> function will return <tt>NULL</tt>.</p>

<h3 id="performance">Performance considerations</h3>

<p>In general, Mill is extremely lightweight. There are no memory allocations,
except int the following cases:</p>

<ol>
  <li>When new coroutine is started.</li>
  <li>When new channel is created.</li>
</ol>

</body>
</html>

