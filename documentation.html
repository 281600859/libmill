<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>libmill</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>

<img src="libmill.png"/>

<p><b>Go-style concurrency in C</b></p>

<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="tutorial.html">Tutorial</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="development.html">Development</a></li>
<li><a href="community.html">Community</a></li>
</ul>

<h2>Documentation</h2>

<ul id="toc">
  <li><a href="#build">Build</a></li>
  <li><a href="#coroutines">Coroutines</a></li>
  <li><a href="#channels">Channels</a></li>
  <li><a href="#choose">Choose statement</a></li>
  <li><a href="#deadlines">Deadlines</a></li>
  <li><a href="#sleeping">Sleeping</a></li>
  <li><a href="#fds">Waiting for file descriptors</a></li>
  <li><a href="#tcp">TCP library</a></li>
  <li><a href="#unix">UNIX library</a></li>
  <li><a href="#udp">UDP library</a></li>
  <li><a href="#cls">Coroutine-local storage</a></li>
  <li><a href="#debug">Debugging</a></li>
</ul>

<h3 id="build">Build</h3>

<p>Libmill runs in following environments:</p>

<ul>
  <li>Microarchitecture: x86_64, ARM</li>
  <li>Compiler: gcc, clang</li>
  <li>Operating system: Linux, OSX, FreeBSD</li>
</ul>

<p>Whether it works in different environments is not known - please, do report
any successes or failures on the project mailing list.</p>

<t>Download the package from the download page. Then build and install
as follows:</p>

<pre>
$ tar -xzf libmill-0.13-beta.tar.gz
$ cd libmill-0.13-beta
$ ./configure
$ make
$ make check
$ sudo make install
</pre>

<p>After the installation there's <tt>libmill.h</tt> header file available
as well as dynamic library <tt>libmill.so</tt> and static library
<tt>libmill.a</tt>.</p>

<p>A program using the library can look like this:</p>

<pre>
#include &lt;stdio.h&gt;
#include "libmill.h"

void worker(int count, const char *text) {
    int i;
    for(i = 0; i != count; ++i) {
        printf("%s\n", text);
        msleep(10);
    }
}

int main() {
    go(worker(4, "a"));
    go(worker(2, "b"));
    go(worker(3, "c"));
    msleep(100);
    return 0;
}
</pre>

<p>To build the example:</p>

<pre>
gcc -o example example.c -lmill
</pre>

<h3 id="coroutines">Coroutines</h3>

<p>Any function can be executed as a coroutine using <tt>go</tt> keyword:</p>

<pre>
void foo(int i, int j) {
    ...
}

int main() {
    go(foo(1, 2));
    return 0;
}
</pre>

<p>However, keep in mind that coroutines are executed asynchronously and thus,
even if the function returns a value, there is now way to retrieve it.</p>

<p>Also bear in mind that coroutines are scheduled in a cooperative fashion.
If one coroutine blocks, for example by calling <tt>sleep()</tt>, it blocks
the entire process. Therefore, coroutine-friendly versions of blocking functions
(such as <tt>msleep()</tt> or <tt>fdwait()</tt>, see below) should be used.</p>

<p>In case of need, you can yield CPU to other coroutines explicitly:</p>

<pre>
yield();
</pre>

<h3 id="channels">Channels</h3>

<p>Channels are typed pipes used for communication between coroutines. To create
a channel you have to specify what kind of values are meant to be passed
through it. The second parameter is buffer size. Setting this argument
to zero creates an unbuffered channel:</p>

<pre>
chan ch = chmake(int, 0);
</pre>

<p>To send a value to the channel use <tt>chs()</tt> function. The type
specified as the second parameter must match the type of the channel otherwise
you'll get runtime exception:</p>

<pre>
chs(ch, int, 42);
</pre>

<p>To receive a value from the channel use <tt>chr()</tt> function. The type
specified as the second parameter must match the type of the channel otherwise
the program will abort with runtime exception:</p>

<pre>
int i = chr(ch, int);
</pre>

<p>When sender is done with sending it can announce the fact using
<tt>chdone()</tt> function. It will cause all the receivers on the channel to
receive the value specified in the third parameter indefinitely:</p>

<pre>
chdone(ch, int, -1);
</pre>

<p>To deallocate the channel use <tt>chclose()</tt> function:</p>

<pre>
chclose(ch);
</pre>

<p>Note that <tt>chclose()</tt> deallocates any elements remaining the channel,
however, if the element itself has a pointer to a different object, that object
won't be deallocated. In this respect <tt>chclose()</tt> is similar to the
standard <tt>free()</tt> function.</p>

<p>When sharing a channel between two or more coroutines you can duplicate
the channel handle. Channel is deallocated only after all its handles
are closed. For example:</p>

<pre>
void sender(chan ch) {
    chs(ch, int, 42);
    chclose(ch);
}

int main() {
    chan ch = chmake(int, 0);
    go(sender(chdup(ch)));
    int i = chr(ch, int);
    assert(i == 42);
    chclose(ch);
    return 0;
}
</pre>

<h3 id="choose">Choose statement</h3>

<p>Choose statement is equivalent to Go's <tt>select</tt> statement. It can be
used to wait for multiple channels.</p>

<p>Within <tt>choose</tt> there's a list of clauses. Each clause is either an
<tt>in</tt> clause (waiting for incoming messages) or an <tt>out</tt> clause
(waiting till a message can be sent to the channel). Last cause can optionally
be an <tt>otherwise</tt> clause. Don't forget to add <tt>end</tt> keyword before
the closing parenthesis:</p>

<pre>
choose {
in(ch1, int, val):
    printf("Value %d received from ch1.\n", val);
out(ch2, int, 42):
    printf("Value 42 sent to ch2.\n");
otherwise:
    printf("Neither ch1 nor ch2 can be used at the moment.\n");
end
}
</pre>

<p>Clause <tt>in</tt> causes <tt>choose</tt> to wait for a message coming
from channel <tt>ch</tt>. The clause declares variable <tt>var</tt> of type
<tt>type</tt> and stores the incoming message into it. If <tt>type</tt> doesn't
match the actual type of the channel you'll get a runtime exception:</p>

<pre>
in(ch, type, var):
</pre>

<p>Clause <tt>out</tt> causes <tt>choose</tt> to wait while value <tt>val</tt>
of type <tt>type</tt> can be sent to channel <tt>ch</tt>. Same way as with
</tt>in</tt>, if <tt>type</tt> doesn't match the actual type of channel
<tt>ch</tt> runtime exception is generated:</p>

<pre>
out(ch, type, val):
</pre>

<p>Clause <tt>otherwise</tt> is optional. It is executed only if no other
clauses can be matched immediately. Therefore, <tt>choose</tt> statement
with <tt>otherwise</tt> clause will never block.</p>

<p><tt>choose</tt> statement waits for the first clause that can be executed,
executes it and then jumps to the code following the clause. If there are
multiple clauses that can be executed one of them is chosen at random.</p>

<p>There's no fall-through among the clauses.</p>

<h3 id="deadlines">Deadlines</h3>

<p>Unlike standard POSIX functions, libmill uses dealines rather than
timeouts.</p>

<p>Deadline is a point in time when a function should finish. Function
<tt>now()</tt> returns the current point in time. You can add milliseconds to
it to get a point in time in the future. Following example defines a deadline
that expires one second from now:</p>

<pre>
int64_t deadline = now() + 1000;
</pre>

<p>The advantage of deadlines over timeouts is that a single deadline can be
reused in many subsequent function calls without having to worry about
readjusting its value to account for time already elapsed since the deadline
was created.</p>

<p>Value of -1 is used to specify that there is no deadline or, if you will,
that the deadline is infinite.</p>

<h3 id="sleeping">Sleeping</h3>

<p>It was already mentioned that a single call to <tt>sleep()</tt> can block
the entire process. To avoid the problem use <tt>msleep()</tt> instead.
Note that the argument is a deadline, not a timeout:</p>

<pre>
msleep(now() + 1000);
</pre>

<h3 id="fds">Waiting for file descriptors</h3>

<p>To wait for an event from a file descriptor use <tt>fdwait</tt> function:</p>

<pre>
int events = fdwait(fd, FDW_IN | FDW_OUT, -1);
if(events & FDW_IN) {
    ...
}
if(events & FDW_OUT) {
    ...
}
if(events & FDW_ERR) {
    ...
}
</pre>

<p><tt>FDW_IN</tt> waits until there's at least one byte available to be
read from the file descriptor.</p>

<p><tt>FDW_OUT</tt> waits until at least one byte can be written to the file
descriptor.</p>

<p><tt>FDW_ERR</tt> cannot be used as an argument to <tt>fdwait()</tt>, but it
can be returned from the function irrespective of whether you want it or
not.</p>

<p>If an error happens while there are still bytes to be received from the
socket combination of <tt>FDW_ERR</tt> and <tt>FDW_IN</tt> may be returned.

<p>The third parameter to <tt>fdwait()</tt> is a deadline. If deadline is hit
the function returns zero.</p>

<h3 id="tcp">TCP library</h3>

<p>TCP can be accessed via standard POSIX functions provided that you do it
in a non-blocking way. To save you the trouble though, libmill provides a
simple convenience wrapper for the functionality.</p>

<h4>Connecting to a remote endpoint</h4>

<p>To connect to a remote server, use <tt>tcpconnect()</tt> function:

<pre>
tcpsock s = tcpconnect("192.168.0.111", 5555, -1);
</pre>

<p>The arguments are IP address (either IPv4 or IPv6), port number and a
deadline.</p>

<p>In case of error the function returns NULL and sets <tt>errno</tt> to one
of the standard POSIX error values. If the deadline is reached, <tt>errno</tt>
is set to <tt>ETIMEDOUT</tt>.</p>

<h4>Listening for incoming connections</h4>

<p>To start listening for incoming TCP connections use <tt>tcplisten()</tt>
function. To accept a new connection use <tt>tcpaccept()</tt> function:</p>

<pre>
tcpsock ls = tcplisten(NULL, 5555);
while(1) {
    tcpsock s = tcpaccept(ls, -1);
    ...
}
</pre>

<p><tt>tcplisten()</tt> arguments are IP address (either IPv4 or IPv6) of the
local network interface to bind to and a port number. If the address is NULL,
all local interfaces will be used. If port number is zero an ephemeral port
number will be chosen by the operating system. In such case you can retrieve the
port number using <tt>tcppport()</tt> function:</p>

<pre>
tcpsock ls = tcplisten("192.168.0.111", 0);
int port = tcpport(ls);
</pre>

<p>In case of error <tt>tcplisten()</tt> function returns NULL and sets
<tt>errno</tt> to one of the standard POSIX error values.</p>

<p><tt>tcpaccept()</tt> function takes the listening socket and a deadline
as arguments and returns the newly accepted socket:</p>

<pre>
tcpsock s = tcpaccept(ls, now() + 1000);
</pre>

<p>In case of error it returns NULL and sets <tt>errno</tt> to one of the
standard POSIX error values. If the deadline is reached, <tt>errno</tt>
is set to <tt>ETIMEDOUT</tt>.</p>

<h4>Sending data</h4>

<p>To send data to the connection use <tt>tcpsend()</tt> function:</p>

<pre>
size_t nbytes = tcpsend(s, "ABC", 3, -1);
</pre>

<p>The arguments are the socket to send the data to, the buffer to send,
number of bytes to send and a deadline. Number of bytes actually sent
is returned.</p>

<p>In the case of success, <tt>errno</tt> is set to zero. If the connection
is broken it is set to <tt>ECONNRESET</tt>. If the deadline expires it is
set to <tt>ETIMEDOUT</tt>.</p>

<p>To optimise the throughput <tt>tcpwrite()</tt> may store the data into output
buffer and not flush it into the network immediately. To force actual sending
of the data use <tt>tcpflush</tt> function.</p>

<pre>
tcpflush(s, -1);
</pre>

<p>Arguments are the socket to flush and a deadline.</p>

<p>In the case of success, <tt>errno</tt> is set to zero. If the connection
is broken it is set to <tt>ECONNRESET</tt>. If the deadline expires it is
set to <tt>ETIMEDOUT</tt>.</p>

<h4>Receiving data</h4>

<p>To read data from a connection use <tt>tcprecv()</tt> function:</p>

<pre>
size_t nbytes = tcprecv(s, buf, 256, -1);
</pre>

<p>The arguments are the socket to receive from, the buffer to receive to,
size of the buffer and a deadline. Number of bytes actually received is
returned.</p>

<p>In the case of success, <tt>errno</tt> is set to zero. If the connection
breaks it is set to <tt>ECONNRESET</tt>. If the deadline expires it is
set to <tt>ETIMEDOUT</tt>.</p>

<p>To help with dealing with text-based protocols libmill provides
<tt>tcprecvuntil()</tt> function. It acts the same as <tt>tcpread()</tt> except
that the reading stops when a specific character is encountered:</p>

<pre>
size_t nbytes = tcprecvuntil(conn, buf, 256, '\n', -1);
</pre>

<p>The arguments are the socket to receive from, the buffer to receive to,
size of the buffer, the delimiter character and a deadline. Number of bytes
actually received, including the delimiter character, is returned.</p>

<p>In the case of success, <tt>errno</tt> is set to zero. If the connection
breaks it is set to <tt>ECONNRESET</tt>. If the deadline expires it is
set to <tt>ETIMEDOUT</tt>. If the entire buffer was filled without encountering
the delimiter character, <tt>errno</tt> is set to <tt>ENOBUFS</tt>.</p>

<h4>Cleaning up</h4>

<p>To close sockets (both listening and connected ones) use <tt>tcpclose()</tt>
function:</p>

<pre>
tcpclose(s);
</pre>

<h3 id="unix">UNIX library</h3>

<p><b>This feature is experimental only!</b></p>

<p>Unix sockets are used for communicating between processes on the same
machine.</p>

<p>The API is identical to the TCP API with all <tt>tcp</tt> prefixes replaced
by <tt>unix</tt> prefixes, e.g. <tt>unixsock</tt> or <tt>unixrecv()</tt>.</p>

<p>Additionally, addresses passed to <tt>unixlisten()</tt> and
<tt>unixconnect()</tt> represent are names of a local files rather than
IP addresses. Also, there are no ports:</tt>

<pre>
unixsock s = unixconnect("/tmp/test.unix");
</pre>

<h3 id="udp">UDP library</h3>

<p><b>This feature is experimental only!</b></p>

<p>To open an UDP socket use <tt>tcplisten()</tt> function. IP address of the
local network interface and port should be supplied. If the address is NULL
the socket will bind to all local network interfaces:</p>

<pre>
udpsock s = udplisten("192.168.0.111", 5555);
</pre>

<p>If port is set to zero operating system selects an unused port. The number
of the port can be retrieved using <tt>udpport()</tt> function:</tt>

<pre>
int port = udpport(s);
</pre>

<p>Once the socket is open it can be immediately used for both sending and
receiving.</p>

<p>Given that UDP transport is unconnected by its very nature and address of
the remote endpoint has to be used in each <tt>udpsend()</tt> and
<tt>udprecv()</tt> call, libmill's UDP library uses binary version of
the address to avoid excessive string processing.</p>

<tt>udpaddr</tt> type represents the binary address and <tt>udpresolve()</tt>
function can be used to convert textual address to the binary one:</tt>

<pre>
udpaddr addr = udpresolve("192.168.0.121", 5555);
</pre>

<p>To send a packet to the remote peer with address <tt>addr</tt> use
<tt>udpsend()</tt> function:</p>

<pre>
udpsend(s, addr, "Hello, world!", 13);
</pre>

<p>The function has no return value but in the case of failure it sets
<tt>errno</tt> to the appropriate value. If there is no error <tt>errno</tt>
is set to zero.</p>

<p>Note that <tt>udpsend()</tt> has no deadline. UDP transport is unreliable
and the packet is either delivered or lost, but never blocked.</p>

<p>To receive a packet from the socket use <tt>udprecv()</tt> function.
If successful the function will return the size of the received packet,
in bytes, and set <tt>udpaddr</tt> passed in the parameter to the source
address of the packet:</p>

<pre>
char buf[256];
udpaddr addr;
size_t sz = udprecv(s, &addr, buf, sizeof(buf), -1);
</pre>

<p>In the case of failure <tt>errno</tt>is set to the appropriate error.
In the case of success <tt>errno</tt> is set to zero.</p>

<p>When done close the UDP socket:</p>

<pre>
udpclose(s);
</pre>

<h3 id="cls">Coroutine-local storage</h3>

<p>Coroutine-local storage is an advanced mechanism meant to be used in
special cases. Avoid using it if possible. In general, use it where you would
use thread-local storage in a threaded program. TLS itself cannot be used with
libmill as multiple coroutines can share the same OS thread.</p>

<p>Coroutine local data are a single pointer which can be set like this:</p>

<pre>
void *data = ...;
setcls(data);
</pre>

<p>Later on the pointer can be accessed anywhere within the coroutine or any
function invoked from it using <tt>cls</tt> function:</p>

<pre>
void *data = cls();
</pre>

<p>It can be safely assumed that before coroutine-local data are set,
<tt>cls</tt> function will return <tt>NULL</tt>.</p>

<h3 id="debug">Debugging</h3>

<p>Libmill provides a couple of functions to help with the debugging. They can
be invoked either directly from the program or manually from the debugger.</p>

<p>When inspecting debug output following rules apply:</>

<ol>
  <li>Both coroutines and channels are represented by decimal IDs.</li>
  <li>The IDs are never re-used, even if the original object was already
      deallocated.</li>
  <li>Coroutine IDs are printed in curly braces, e.g. <tt>{24}</tt>.</li>
  <li>Channel IDs are printed in pointy braces, e.g. <tt>&lt;24&gt;</tt>.</li>
</ol>

<h4>goredump</h4>

<p>When debugging a program you may want to inspect the coroutines being
run and the channels being used. Use <tt>goredump</tt> function to do
exactly that.</p>

<p>Here's an example of how to use it directly from a <tt>gdb</tt>
   session:</p>

<pre>
Breakpoint 1, main () at foo.c:57
57	    if(quux &lt; 0) {
(gdb) p goredump()

COROUTINE  state                  current           created
----------------------------------------------------------------------
{0}        RUNNING                ---               &lt;main&gt;
{7}        chs(&lt;7&gt;)               foo.c:63          foo.c:157
{8}        chr(&lt;8&gt;)               foo.c:63          foo.c:158
{14}       choose(&lt;14&gt;,&lt;14&gt;)      foo.c:70          foo.c:258
{15}       ready                  foo.c:35          foo.c:276

CHANNEL  msgs/max    senders/receivers     refs  done  created
----------------------------------------------------------------------
&lt;7&gt;      0/0         s:{7}                 2     no    foo.c:155
&lt;8&gt;      0/0         r:{8}                 2     no    foo.c:156
&lt;14&gt;     0/0         s:{14},{14}           2     no    foo.c:257
&lt;15&gt;     22/100                            1     yes   foo.c:274

$2 = void
(gdb) 
</pre>

<p>The first section is coroutine dump. It contains the list of all coroutines,
each accompanied by its ID, state, the line of code that's it is executing at
the moment and to the line that originally created the coroutine.</p>

<p>The dump doesn't contain coroutine name. To map the coroutine record to
the actual coroutine in the code, check the line referenced by 'created'
field.</p>

<p>The 'state' field gives you more information about the operation being
performed. When a coroutine is blocked in <tt>chr</tt> call, for example,
you'll also see the ID of the channel it is trying to receive from:</p>

<pre>
COROUTINE  state                  current           created
----------------------------------------------------------------------
{8}        chr(&lt;8&gt;)               foo.c:63          foo.c:158
</pre>

<p>When <tt>choose</tt> statement is being executed a list of channel IDs
is provided, corresponding to the list of clauses in the <tt>choose</tt>
statement:</p>

<pre>
COROUTINE  state                  current           created
----------------------------------------------------------------------
{14}       choose(&lt;5&gt;,&lt;3&gt;)        foo.c:22          foo.c:107
</pre>

<p>If there are any channels created by the user coroutine dump will be followed
by a channel dump. Each record in the dump corresponds to one channel instance
and contains its ID, number of messages buffered in the channel, channel
capacity, its reference count, whether <tt>chdone()</tt> was already called
and a the line of code that created the channel.</p> 

<p>Additionally, if there are any coroutines waiting for messages from the
channel -- whether via <tt>chr</tt> or <tt>choose</tt> -- they are reported
like this:</p>

<pre>
CHANNEL  msgs/max    senders/receivers     refs  done  created
----------------------------------------------------------------------
&lt;1&gt;      0/0         r:{4},{5}             2     no    foo.c:391
</pre>

<p>The waiting coroutines are served in the displayed order, i.e. when a new
message is sent to the channel it will be dispatched to coroutine 4. Next one
will go to coroutine 5 and so on.</p>

<p>Similarly, if there are coroutines trying to send message to the channel
but unable to do so becuase the channel's buffer if full they are reported in
the following way:</p>

<pre>
CHANNEL  msgs/max    senders/receivers     refs  done  created
----------------------------------------------------------------------
&lt;1&gt;      100/100     r:{2},{13}            2     no    foo.c:392
</pre>

<p>If there are no coroutines waiting to send or receive messages from the
channel the field is kept empty.</p>

<h4>gotrace</h4>

<p>It is possible to switch on tracing via <tt>gotrace()</tt> function. You can
do so either programmatically or from the debugger:</p>

<pre>
gotrace(1);
</pre>

<p>The function takes a single argument, the desired tracing level.
At the moment there are only two supported tracing levels:</p>

<ul>
  <li>0: tracing is off; this is the default value.</li>
  <li>1: invocations of all libmill functions are traced.</li>
</ul>

<p>Trace records are written to <tt>stderr</tt>. That way it is possible to
redirect the trace records to a file, while keeping the original output of the
program in the console:</p>

<pre>
$ ./test 2> trace.log
</pre>

<p>A part of the trace may look, for example, like this:</p>

<pre>
==> 22:24:56.404183 {0}      &lt;1&gt;=chmake(0) at tests/choose.c:113
==> 22:24:56.404276 {0}      {1}=go() at tests/choose.c:114
==> 22:24:56.404292 {1}      chdup(&lt;1&gt;) at tests/choose.c:114
==> 22:24:56.404304 {1}      chr(&lt;1&gt;) at tests/choose.c:30
==> 22:24:56.404316 {0}      choose() at tests/choose.c:115
==> 22:24:56.404354 {0}      chclose(&lt;1&gt;) at tests/choose.c:120
</pre>

<p>Each trace record contains timestamp, ID of the coroutine that have generated
the trace, the function being executed along with its arguments and the location
of its invocation in the source code.</p>

<p>The format is designed to be machine-friendly and, more specifically,
grep-friendly.</p>

<p>If you have a file that mixes trace records with other output, grep will
help you filter out the trace records:</p>

<pre>
$ grep "==>" trace.log
</pre>

<p>Similarly, you can filter out records related to a particular coroutine
or a specific channel:</p>

<pre>
$ grep "{9}" trace.log
$ grep "&lt;33&gt;" trace.log
</pre>

</body>
</html>

