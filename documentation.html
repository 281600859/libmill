<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Mill</title>
  <style>
  body {font-family:sans-serif;} 
  #toplist {
    padding-left: 0px;
  }
  #toplist li {
    display: inline;
    list-style-type: none;
    padding-right: 15px;
  }
  a {color:#000000;}
  </style>
</head>
<body>
<div style="width:50em">

<h1>Mill - C language with coroutines</h1>

<b>
<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="documentation.html">Documentation</a></li>
</ul>
</b>

<h2>Documentation</h2>

<h3>Introduction to coroutines</h3>

<p>Coroutines are a way to implement cooperative multitasking in a rather simple
and developer-friendly manner.</p>

<p>If you are not familiar with coroutines, check the wikipedia article here:</p>

<p><a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a></p>

<p>A nice explanation of how to implement coroutines in C can be found here:</p>

<p><a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a></p>

<h3>Mill</h3>

<p>To use coroutines, it is best to choose a language that has direct support for
the concept, such as Go.</p>

<p>However, sometimes there is no other option but to use C. After all, C is
the lingua franca of programming languages. Every other language integrates
well with C. C works on any operating system. Et c.</p>

<p>Writing coroutines by hand (see the link above) is an option, but once you
move beyond the very basic functionality all the required boilerplate code is
both annoying to write and confusing to read.</p>

<p>Mill tries to solve this problem by defining a slightly augmented version of
C language, one with direct support for coroutines.</p>

<p>Mill is more than a coroutine generator though. It tries to tame the
complexity inherent in asynchronous programming by defining additional
constrains on what can be done. For example, the lifetime of coroutine must be
fully contained in the lifetime of the coroutine that launched it. In other
words, when coroutine ends, all the child coroutines are automatically canceled.
Another example: Each coroutine can communicate only with its parent coroutine
and can send it only a single "I am done" message.</p>

<p>The hope is that such constrains won't affect expressivity of the language,
yet, they will make the code cleaner, simpler and easier to understand and
maintain.</p>

</h3>Usage</h3>

<p>Following commands will generate foo.h from foo.mh and foo.c from foo.mc:</p>

<pre>
$ mill foo.mh
$ mill foo.mc
</pre>

</h3>Defining a coroutine</h3>

<p>Use "coroutine" keyword to define a new coroutine. The syntax mimics the
syntax of standard C function, except that it has no return value:</p>

<pre>
coroutine foo (int a, const char *b, int *result)
{
    *result = a + b;
}
</pre>

<p>Mill is a simple preprocessor that doesn't do full semantic analysis of the
source. The price for such simplicity is that it is not able to automatically
distinguish variable declarations from the other stuff in the codebase. To help
the parser, you must place all the local variable declarations to the beginning
of the coroutine. The declarations must be followed by "endvars" keyword:</p>

<pre>
coroutine foo ()
{
    int i = 0;
    endvars;

    i = i + 1
}
</pre>

<p>WARNING: If you put local variable declarations elsewhere, mill won't
complain about the fact but the behaviour of the coroutine will become
undefined. Expect values of such variables to change randomly while coroutine is
in progress.</p>

<h3>Coroutine aliasing</h3>

<p>You can define new coroutine to have exactly the same behaviour as a
different coroutine:</p>

<pre>
coroutine foo = bar;
</pre>

<p>While the construct looks a bit superfluous, it is actually quite important
tool for keeping the codebase simple. Usage of the construct will be discussed
in subsequent sections.</p>

<h3>Launching coroutines</h3>

<p>Use "go" keyword to launch a coroutine:</p>

<pre>
coroutine foo ()
{
    printf ("Hello, world!\n");
}

coroutine bar ()
{
    go foo();
}
</pre>

<p>The coroutine will be executed in parallel with the parent coroutine.</p>

<p>Please note that coroutines can be launched in this way only from other
coroutines. If you want to launch a coroutine from standard C function you
have to do so in synchornous manner:</p>

<pre>
coroutine foo ()
{
    printf ("Hello, world!\n");
}

int main ()
{
    foo ();
    return 0;
}
</pre>

<p>In this case the coroutine won't execute in parallel with the parent 
function. Instead, the function will be blocked until the coroutine is
finished.</p>

<h3>Waiting for coroutines</h3>

<p>Use "select" keyword to wait for termination of child coroutines:</p>

<pre>
coroutine foo ()
{
}

coroutine bar ()
{
    go foo ();
    select {
    case foo:
        printf ("foo is done\n");
    }
}
</pre>

<p>Note that you are waiting for a specific *type* of coroutine rather than for
specific coroutine invocation. Thus, in the following example "select" waits
for termination of any of the child coroutines:</p>

<pre>
coroutine bar ()
{
    go foo ();
    go foo ();
    go foo ();

    while (1) {
        select {
        case foo:
            printf ("foo is done!\n");
        }
    }
}
</pre>

<h3>Returning data from coroutines</h3>

<p>Coroutines have no return values. However, you can use standard output
parameters and they should work as expected:</p>

<pre>
coroutine foo (int *result)
{
    *result = 1;
}

coroutine bar ()
{
    int i;
    endvars;

    go foo (&i);

    select {
    case foo:
        assert (i == 1);
    }
}
</pre>

<p>There's a problem though if multiple coroutines write the result into a
single location:</p>

<pre>
coroutine foo (int *result, int i)
{
    *result = i;
}

coroutine bar ()
{
    int i;
    endvars;

    go foo (&i, 1);
    go foo (&i, 2);

    select {

    // This clause may be invoked because foo(1) have ended, thus i == 1.
    case foo: 

        // foo(2) ends here and stores value 2 into i.
        assert (i == 1); // Assert fails.
    }
}
</pre>

<p>To address this problem "out" keyword is introduced. The coroutine argument
marked as "out" is allocated at callee's coframe (like a stack frame, but for
coroutines) and copied to the caller-specified destination immediately before
coroutine termination event is processed by the caller:</p>

<pre>
coroutine foo (out int *result, int i)
{
    *result = i;
}

coroutine bar ()
{
    int i;
    endvars;

    go foo (&i, 1);
    go foo (&i, 2);
    go foo (&i, 3);

    while (1) {
        select {
        case foo:
            printf ("coroutine foo returned %d\n", i);
        }
    }
}
</pre>

<h3>Canceling coroutines</h3>

<p>One of the main principles in mill is that lifetime of a coroutine never
exceeds the lifetime of the coroutine that have launched it.</p>

<p>Therefore, if child coroutine is still being executed when the parent
coroutine is terminating, the former is automatically canceled. There's no need
for any explicit action on parent's behalf.</p>

<p>However, the child coroutine may want to intercept the cancelation and do
any necessary cleanup.</p>

<p>Given that coroutines can be interrupted only while waiting inside a select
statement, the interception can be done by simply adding a 'cancel' clause to
the statement:</p>

<pre>
coroutine foo (out char *result)
{
    result = malloc (14);
    memcpy (result, "Hello, world!", 14);

    go msleep (NULL, 1000);

    select {
    case msleep:
        return;
    cancel:
        free (result);
        return;
    }
}
</pre>

<p>There's one more cancelation scenario: The child coroutine may have been
fully executed, yet the parent coroutine may exit without selecting it. In such
case the coroutine being canceled (the child coroutine) still needs to do
clean-up, specifically, it needs to deallocate any dynamically allocated output
parameters. It can be done by adding the 'cancel' clause to the coroutine
itself:</p>

<pre>
coroutine foo (out char *result)
{
    result = malloc (14);
    memcpy (result, "Hello, world!", 14);
cancel:
    free (result);
}
</pre>

<h3>Comment on memory management</h3>

<p>Keep in mind that coframes are deallocated when the child coroutine is
selected. If you launch a coroutine without selecting it afterwards, the
coframe will linger on in the memory until it is deallocated when the
caller coroutine terminates.</p>

<p>The behaviour is perfectly all right in most circumstances, however,
launching arbitrary number of coroutines in a loop without selecting them can
lead to memory exhaustion:</p>

<pre>
coroutine foo ()
{
    while (1) {
        go msleep (NULL, 1000);
    }
}
</pre>

<h3>Debugging</h3>

<p>To make debugging of the asynchronous system easier, mill has support for
tracing. You can switch it on by invoking "_mill_trace();" function.</p>

<p>The tracing output looks like this:</p>

<pre>
mill ==> go     test
mill ==> go     test/fx1
mill ==> go     test/fx1/msleep
mill ==> go     test/fx2
mill ==> go     test/fx2/msleep
mill ==> return test/fx1/msleep
mill ==> select test/fx1/msleep
mill ==> cancel test/fx2
mill ==> cancel test/fx2/msleep
mill ==> return test/fx2/msleep
mill ==> return test/fx2
mill ==> return test
</pre>

<p>Each line contains an operation and the coroutine's backtrace. So, for
example:</p>

<pre>
mill ==> return test/fx2
</pre>

<p>Means that coroutine "fx2" invoked from top-level coroutine "test" have
finished execution.</p>

</div>
</body>
</html>
