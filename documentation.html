<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>libmill</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>

<img src="libmill.png"/>

<p><b>Go-style concurrency in C</b></p>

<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="tutorial.html">Tutorial</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="development.html">Development</a></li>
<li><a href="community.html">Community</a></li>
</ul>

<h2>Documentation</h2>

<ul id="toc">
  <li><a href="#intro">Introduction</a></li>
  <li><a href="#tour">A tour of the library</a></li>
  <ul id="toc">
    <li><a href="#coroutines">Coroutines</a></li>
    <li><a href="#channels">Channels</a></li>
    <li><a href="#choosestatement">Choose statement</a></li>
    <li><a href="#deadlines">Deadlines</a></li>
    <li><a href="#sleeping">Sleeping</a></li>
    <li><a href="#fds">Waiting for file descriptors</a></li>
    <li><a href="#network">Network</a></li>
    <ul id="toc">
      <li><a href="#ip">IP addresses</a></li>
      <li><a href="#tcp">TCP</a></li>
      <li><a href="#unix">UNIX</a></li>
      <li><a href="#udp">UDP</a></li>
    </ul>
    <li><a href="#clstorage">Coroutine-local storage</a></li>
    <li><a href="#memory">Dealing with memory</a></li>
    <li><a href="#multiprocessing">Multiprocessing</a></li>
    <li><a href="#debug">Debugging</a></li>
  </ul>
  <li><a href="#reference">Reference</a></li>
  <ul id="toc">
    <li><a href="#chclose">chclose</a></li>
    <li><a href="#chdone">chdone</a></li>
    <li><a href="#chdup">chdup</a></li>
    <li><a href="#chmake">chmake</a></li>
    <li><a href="#choose">choose</a></li>
    <li><a href="#chr">chr</a></li>
    <li><a href="#chs">chs</a></li>
    <li><a href="#cls">cls</a></li>
    <li><a href="#coroutine">coroutine</a></li>
    <li><a href="#fdclean">fdclean</a></li>
    <li><a href="#fdwait">fdwait</a></li>
    <li><a href="#go">go</a></li>
    <li><a href="#goprepare">goprepare</a></li>
    <li><a href="#goredump">goredump</a></li>
    <li><a href="#gotrace">gotrace</a></li>
    <li><a href="#ipaddrstr">ipaddrstr</a></li>
    <li><a href="#iplocal">iplocal</a></li>
    <li><a href="#ipremote">ipremote</a></li>
    <li><a href="#mfclose">mfclose</a></li>
    <li><a href="#mfeof">mfeof</a></li>
    <li><a href="#mferr">mferr</a></li>
    <li><a href="#mfflush">mfflush</a></li>
    <li><a href="#mfin">mfin</a></li>
    <li><a href="#mfopen">mfopen</a></li>
    <li><a href="#mfork">mfork</a></li>
    <li><a href="#mfout">mfout</a></li>
    <li><a href="#mfread">mfread</a></li>
    <li><a href="#mfseek">mfseek</a></li>
    <li><a href="#mftell">mftell</a></li>
    <li><a href="#mfwrite">mfwrite</a></li>
    <li><a href="#msleep">msleep</a></li>
    <li><a href="#now">now</a></li>
    <li><a href="#setcls">setcls</a></li>
    <li><a href="#tcpaccept">tcpaccept</a></li>
    <li><a href="#tcpaddr">tcpaddr</a></li>
    <li><a href="#tcpclose">tcpclose</a></li>
    <li><a href="#tcpconnect">tcpconnect</a></li>
    <li><a href="#tcpflush">tcpflush</a></li>
    <li><a href="#tcplisten">tcplisten</a></li>
    <li><a href="#tcpport">tcpport</a></li>
    <li><a href="#tcprecv">tcprecv</a></li>
    <li><a href="#tcprecvuntil">tcprecvuntil</a></li>
    <li><a href="#tcpsend">tcpsend</a></li>
    <li><a href="#udpclose">udpclose</a></li>
    <li><a href="#udplisten">udplisten</a></li>
    <li><a href="#udpport">udpport</a></li>
    <li><a href="#udprecv">udprecv</a></li>
    <li><a href="#udpsend">udpsend</a></li>
    <li><a href="#unixaccept">unixaccept</a></li>
    <li><a href="#unixclose">unixclose</a></li>
    <li><a href="#unixconnect">unixconnect</a></li>
    <li><a href="#unixflush">unixflush</a></li>
    <li><a href="#unixlisten">unixlisten</a></li>
    <li><a href="#unixpair">unixpair</a></li>
    <li><a href="#unixrecv">unixrecv</a></li>
    <li><a href="#unixrecvuntil">unixrecvuntil</a></li>
    <li><a href="#unixsend">unixsend</a></li>
    <li><a href="#yield">yield</a></li>
  </ul>
</ul>

<h3 id="intro">Introduction</h3>

<p>Libmill is a lightweight coroutine library bringing Go-style concurrency
to C language. It also contains simple networking library that allows users to
quickly bootstrap application development.</p>

<p>Libmill runs in following environments:</p>

<ul>
  <li>Microarchitecture: x86_64, ARM</li>
  <li>Compiler: gcc, clang</li>
  <li>Operating system: Linux, OSX, FreeBSD, OpenBSD, NetBSD, DragonFlyBSD</li>
</ul>

<p>Whether it works in different environments is not known - please, do report
any successes or failures to the project mailing list.</p>

<t>Download the package from the download page. Then build and install
as follows:</p>

<pre>
$ tar -xzf libmill-1.8.tar.gz
$ cd libmill-1.8
$ ./configure
$ make
$ make check
$ sudo make install
</pre>

<p>After the installation there's <tt>libmill.h</tt> header file available
as well as dynamic library <tt>libmill.so</tt> and static library
<tt>libmill.a</tt>.</p>

<p>A program using the library can look, for example, like this:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;libmill.h&gt;

coroutine void worker(int count, const char *text) {
    int i;
    for(i = 0; i != count; ++i) {
        printf("%s\n", text);
        msleep(now() + 10);
    }
}

int main() {
    go(worker(4, "a"));
    go(worker(2, "b"));
    go(worker(3, "c"));
    msleep(now() + 100);
    return 0;
}
</pre>

<p>To build and run the example:</p>

<pre>
$ gcc -o example example.c -lmill
$ ./example
</pre>

<p>Alternatively, using static library:</p>

<pre>
$ gcc -o example example.c libmill.a
$ ./example
</pre>

<h3 id="tour">A tour of the library</h3>

<h4 id="coroutines">Coroutines</h4>

<p>Coroutine is defined using <tt><a href="#coroutine">coroutine</a></tt>
keyword and launched using <tt><a href="#go">go</a></tt> construct:</p>

<pre>
coroutine void foo(int i, int j) {
    ...
}

int main() {
    go(foo(1, 2));
    return 0;
}
</pre>

<p>Although coroutine can return a value keep in mind that it is executed
asynchronously and thus there is now way to retrieve the result.</p>

<p>Note that your program may work perfectly well even if you ommit the
<tt><a href="#coroutine">coroutine</a></tt> keyword. However, such program may
break randomly when compiled by a different compiler or with a different
optimisation level (a know problem is with clang and -O2 optimisation level).
</p>

<p>Also bear in mind that coroutines are scheduled in a cooperative fashion.
If one coroutine blocks, for example by calling <tt>sleep()</tt>, it blocks
the entire process. Therefore, coroutine-friendly versions of blocking functions
(such as <tt><a href="#msleep">msleep()</a></tt> or
<tt><a href="#fdwait">fdwait()</a></tt>, see below) should be used.</p>

<p>In case of need, you can <a href="#yield">yield</a> CPU to other coroutines
explicitly:</p>

<pre>
yield();
</pre>

<h4 id="channels">Channels</h4>

<p>Channels are typed uni-directional pipes used for communication between
coroutines. To create a channel use <tt><a href="#chmake">chmake()</a></tt>
function like this:</p>

<pre>
chan ch = chmake(int, 0);
</pre>

<p>This channel can be used to pass integer values. However, one can declare
channel of any type.</p>

<p>The second parameter is the size of the channel's buffer. If it is set to
zero, it means that the channel is unbuffered. Sender will block until there's a
receiver available and vice versa.</p>

<p>If the channel has buffer size set to 100 the sender can send 100 messages
without anyone receiving them. When trying to send 101st message it will block.
</p>

<p>To send a message to the channel use <tt><a href="#chs">chs()</a></tt>
function:</p>

<pre>
chs(ch, int, 42);
</pre>

<p>To receive a message from the channel use <tt><a href="#chr">chr()</a></tt>
function:</p>

<pre>
int i = chr(ch, int);
</pre>

<p>When sender is done with sending it can announce the fact using
<tt><a href="#chdone">chdone()</a></tt> function:</p>

<pre>
chdone(ch, int, -1);
</pre>

<p>The value (third parameter) passed to the function is used to signal to the
receivers that sender is done. Once all the actual messages are read from the
channel any subsequent calls to <tt><a href="#chr">chr()</a></tt> won't block
and will return the specified message instead. The code on the receiver side
typically looks like this:</p>

<pre>
while(1) {
    int i = chr(ch, int);
    if(i == -1)
        break;
    ...
}
</pre>

<p>To deallocate the channel use <tt><a href="#chclose">chclose()</a></tt>
function:</p>

<pre>
chclose(ch);
</pre>

<p>Note that <tt><a href="#chclose">chclose()</a></tt> deallocates any elements
remaining the channel, however, if the element itself has a pointer to a
different object, that object won't get deallocated. In this respect
<tt><a href="#chclose">chclose()</a></tt> is similar to the
standard C <tt>free()</tt> function.</p>

<p>When sharing a channel between two or more coroutines you can duplicate
the channel handle. Channel gets deallocated only after all its handles
are closed. For example:</p>

<pre>
coroutine void sender(chan ch) {
    chs(ch, int, 42);
    chclose(ch);
}

int main() {
    chan ch = chmake(int, 0);
    go(sender(chdup(ch)));
    int i = chr(ch, int);
    assert(i == 42);
    chclose(ch);
    return 0;
}
</pre>

<h4 id="choosestatement">Choose statement</h4>

<p>Choose statement is equivalent to Go's <tt>select</tt>
statement. It can be used to wait for multiple channels.</p>

<p>Inside <tt><a href="#choose">choose</a></tt> statement there is a list of
clauses. Each clause is either an <tt>in</tt> clause (waiting for an incoming
message) or an <tt>out</tt> clause (waiting till a message can be sent to the
channel). Last clause can optionally be a <tt>deadline</tt> or an
<tt>otherwise</tt> clause. The former gets executed after deadline expires,
the latter if none of the other clauses apply. Don't forget to add the <tt>end</tt>
keyword before the closing parenthesis:</p>

<pre>
choose {
in(ch1, int, val):
    printf("Value %d received from ch1.\n", val);
out(ch2, int, 42):
    printf("Value 42 sent to ch2.\n");
otherwise:
    printf("Neither ch1 nor ch2 can be used at the moment.\n");
end
}
</pre>

<p>Clause <tt>in</tt> causes <tt><a href="#choose">choose</a></tt> to wait for a
message coming from the channel. The clause declares variable <tt>var</tt> of
type <tt>type</tt> and sets it to the value of the incoming message.</p>

<pre>
in(ch, type, var):
</pre>

<p>Clause <tt>out</tt> causes <tt><a href="#choose">choose</a></tt> to wait
while value <tt>val</tt> of type <tt>type</tt> can be sent to channel
<tt>ch</tt>. Same way as with </tt>in</tt>, if <tt>type</tt> doesn't match the
actual type of channel <tt>ch</tt> runtime exception is generated:</p>

<pre>
out(ch, type, val):
</pre>

<p>Clause <tt>deadline</tt>, if present, is executed after deadline expires and
none of the other clauses fire before that:</p>

<pre>
deadline(now() + 1000):
</pre>

<p>Clause <tt>otherwise</tt> is optional. It is executed only if no other
clauses can be matched immediately. Therefore,
<tt><a href="#choose">choose</a></tt> statement with <tt>otherwise</tt> clause
will never block.</p>

<p><tt><a href="#choose">choose</a></tt> statement waits for the first clause
that can be executed, executes it and then jumps to the code following the
clause. If there are multiple clauses that can be executed one of them is chosen
at random.</p>

<p>There's no fall-through among the clauses.</p>

<h4 id="deadlines">Deadlines</h4>

<p>Unlike standard POSIX functions, libmill uses deadlines rather than
timeouts.</p>

<p>Deadline is a point in time when a function should finish. Function
<tt><a href="#now">now()</a></tt> returns the current point in time. You can
add milliseconds to it to get a point in time in the future. Following example
defines a deadline that expires one second from now:</p>

<pre>
int64_t deadline = now() + 1000;
</pre>

<p>The advantage of deadlines over timeouts is that a single deadline can be
reused in many subsequent function calls without having to worry about
readjusting its value to account for time already elapsed since the deadline
was created.</p>

<p>Value of -1 is used to specify that there is no deadline or, if you will,
that the deadline is infinite.</p>

<h4 id="sleeping">Sleeping</h4>

<p>It was already mentioned that a single call to <tt>sleep()</tt> can block
the entire process. To avoid the problem use
<tt><a href="#msleep">msleep()</a></tt> instead. Note that the argument is a
deadline, not a timeout:</p>

<pre>
msleep(now() + 1000);
</pre>

<h4 id="fds">Waiting for file descriptors</h4>

<p>To wait for an event from a file descriptor use
<tt><a href="#fdwait">fdwait</a></tt> function:</p>

<pre>
int events = fdwait(fd, FDW_IN | FDW_OUT, -1);
if(events & FDW_IN) {
    ...
}
if(events & FDW_OUT) {
    ...
}
if(events & FDW_ERR) {
    ...
}
</pre>

<p><tt>FDW_IN</tt> waits until there's at least one byte available to be
read from the file descriptor.</p>

<p><tt>FDW_OUT</tt> waits until at least one byte can be written to the file
descriptor.</p>

<p><tt>FDW_ERR</tt> cannot be used as an argument to
<tt><a href="#fdwait">fdwait()</a></tt>, but it can be returned from the
function irrespective of whether you want it or not.</p>

<p>If an error happens while there are still bytes to be received from the
socket combination of <tt>FDW_ERR</tt> and <tt>FDW_IN</tt> may be returned.

<p>The third parameter to <tt><a href="#fdwait">fdwait()</a></tt> is a deadline.
If deadline is hit the function returns zero.</p>

<p>When handling the file descriptors directly (as opposed to using
<tt>tcpsock</tt>, <tt>unixsock</tt> or <tt>udpsock</tt>) you have to call
<tt>fdclean()</tt> before closing any file descriptor you've previously
used with <tt>fdwait()</tt>. It will drop any cached state <tt>fdwait()</tt>
may have associated with the descriptor. If you don't do so undefined, hard to
debug behaviour is likely to ensue.</p>

<pre>
fdclean(fd);
close(fd);
</pre>

<p>As for the file descriptors you don't own, as, for example, file descriptors
temporarily handed to you by a third party library you should use
<tt>fdclean()</tt> before returning the ownership to the original owner.</p>

<h4 id="network">Network</h4>

<p>Network functionality, such as TCP or UDP, can be accessed via standard POSIX
functions provided that you do it in a non-blocking way. To save you the trouble
though, libmill provides a simple convenience wrapper on top of it.</p>

<h5 id="ip">IP addresses</h5>

<p>To use TCP or UDP you need IP addresses first. The wrapper type for IP
addresses (both IPv4 and IPv6) is called <tt>ipaddr</tt>. It also
includes port number. Unlike address types in POSIX it can be used as a basic
type. It can be assigned, returned from a function and so on.</p>

<p>There are two functions to construct IP addresses:
<tt><a href="#iplocal">iplocal()</a></tt> that retrieves the IP address of a
local network interface and <tt><a href="#ipremote">ipremote()</a></tt> that
gets IP address of a remote machine. In addition to that, certain other library
functions, (<tt><a href="#udprecv">udprecv()</a></tt>,
<tt><a href="#tcpaddr">tcpaddr()</a></tt>) return IP addresses.</p>

<p><tt><a href="#iplocal">iplocal()</a></tt> converts a textual form of IP
address, or a name of a local network interface and a port number into
<tt>ipaddr</tt>:</p>

<pre>
ipaddr addr1 = iplocal("127.0.0.1", 3333, 0);
ipaddr addr2 = iplocal("::1", 4444, 0);
ipaddr addr3 = iplocal("eth0", 5555, 0);
</pre>

<p>The last (<tt>mode</tt>) argument specifies which kind of addresses you are
interested in. Possible values are:</p>

<ul>
  <li><tt>IPADDR_IPV4</tt>: get IPv4 address or error if it's not available</li>
  <li><tt>IPADDR_IPV6</tt>: get IPv6 address or error if it's not available</li>
  <li><tt>IPADDR_PREF_IPV4</tt>: get IPv4 address if possible, IPv6 address
      otherwise; error if none is available</li>
  <li><tt>IPADDR_PREF_IPV6</tt>: get IPv6 address if possible, IPv4 address
      otherwise; error if none is available</li>
</ul>

<p>Setting the argument to zero means default behaviour, which, at the
present, is <tt>IPADDR_PREF_IPV4</tt>. However, in the future when IPv6 becomes
more common it may be switched to <tt>IPADDR_PREF_IPV6</tt>.</p>

<p>If address parameter is set to NULL, <tt>INADDR_ANY</tt> or
<tt>in6addr_any</tt> is returned. This value is useful when binding to all local
network interfaces.</p>

<p>The second function to produce IP addresses is
<tt><a href="#ipremote">ipremote()</a></tt>. It resolves remote host name to
an IP address.</p>

<p>Given that remote host name resolution may involve a DNS query which in
turn can take non-trivial amount of time,
<tt><a href="#ipremote">ipremote()</a></tt> has also deadline parameter.</p>

<pre>
ipaddr addr = ipremote("192.168.0.111", 5555, 0, -1);
</pre>

<p>Both <tt><a href="#iplocal">iplocal()</a></tt> and
<tt><a href="#ipremote">ipremote()</a></tt> report errors in the same
way. They set <tt>errno</tt> to appropriate error code. Additionally, returned
address has family type AF_UNSPEC which will cause any function you pass it to
fail.</tt></p>

<p>You can also convert <tt>ipaddr</tt> into a human readable string. To do so
you have to supply a buffer at least <tt>IPADDR_MAXSTRLEN</tt> long:</p>

<pre>
ipaddr addr = ...;
char buf[IPADDR_MAXSTRLEN];
printf("Connecting to %s!\n", ipaddrstr(addr, buf));
</pre>

<h5 id="tcp">TCP</h5>

<h6>Connecting to a remote endpoint</h6>

<p>To connect to a remote server, use
<tt><a href="#tcpconnect">tcpconnect()</a></tt> function:

<pre>
ipaddr addr = ipremote("192.168.0.111", 5555, 0, -1);
tcpsock s = tcpconnect(addr, -1);
</pre>

<h6>Listening for incoming connections</h6>

<p>To start listening for incoming TCP connections use
<tt><a href="#tcplisten">tcplisten()</a></tt> function. To accept a new
connection use <tt><a href="#tcpaccept">tcpaccept()</a></tt> function:</p>

<pre>
ipaddr addr = iplocal("eth0", 5555, 0);
tcpsock ls = tcplisten(addr, 10);
while(1) {
    tcpsock s = tcpaccept(ls, -1);
    ...
}
</pre>

<p>First argument is an IP address of the local network interface
to bind to. Use <tt>iplocal(NULL, port, 0)</tt> to bind to all local
interfaces.</p>

<p>If port number is zero an ephemeral port number will be chosen by
the operating system. In such case you can retrieve the port number using
<tt><a href="#tcpport">tcppport()</a></tt> function:</p>

<pre>
ipaddr addr = iplocal(NULL, 0, 0);
tcpsock ls = tcplisten(addr, 10);
int port = tcpport(ls);
</pre>

<p><tt><a href="#tcpaccept">tcpaccept()</a></tt> function takes the listening
socket as argument and returns the newly accepted socket:</p>

<pre>
tcpsock s = tcpaccept(ls, -1);
</pre>

<p>After accepting new connection you can retrieve IP address of the peer
using <tt><a href="#tcpaddr">tcpaddr()</a></tt> function:

<pre>
tcpsock s = tcpaccept(ls, -1);
ipaddr peer = tcpaddr(s);
</pre>

<h6>Sending data</h6>

<p>To send data to the connection use <tt><a href="#tcpsend">tcpsend()</a></tt>
function:</p>

<pre>
size_t nbytes = tcpsend(s, "ABC", 3, -1);
</pre>

<p>Number of bytes actually sent is returned. Given that libmill functions
generally work in blocking-like fashion the result will be equal to number
of bytes requested, unless an error has occured.</p>

<p>To optimise the throughput <tt><a href="#tcpsend">tcpsend()</a></tt> may
store the data into output buffer and not flush it into the network immediately.
To force actual sending of the data use
<tt><a href="#tcpflush">tcpflush()</a></tt> function.</p>

<pre>
tcpflush(s, -1);
</pre>

<p>Keep in mind that not flushing the data can mean that it will never appear at
the peer.</p>

<h6>Receiving data</h6>

<p>To read data from a connection use <tt><a href="#tcprecv">tcprecv()</a></tt>
function:</p>

<pre>
char buf[256];
size_t nbytes = tcprecv(s, buf, sizeof(buf), -1);
</pre>

<p>Similarly as with <tt><a href="#tcpsend">tcpsend()</a></tt>,
<tt><a href="#tcprecv">tcprecv()</a></tt> returns number of bytes received
and the value should match the number of bytes requested unless there is an
error or deadline is reached.</p>

<p>To help with dealing with text-based protocols libmill provides
<tt><a href="#tcprecvuntil">tcprecvuntil()</a></tt> function. It acts the same
as <tt><a href="#tcpread">tcpread()</a></tt> except that the reading stops when
one of specified characters is encountered:</p>

<pre>
char buf[256];
size_t nbytes = tcprecvuntil(conn, buf, sizeof(buf), "\n" , 1, -1);
</pre>

<p>The arguments are the socket to receive from, the buffer to receive to,
size of the buffer, the delimiter characters, how many of them are there
and a deadline.

<p>Number of bytes actually received, including the delimiter character,
if found, is returned. If the entire buffer was filled without encountering
the delimiter character, <tt>errno</tt> is set to <tt>ENOBUFS</tt>.</p>

<p>Keep in mind that mutliple delimiter characters means that receiving stops
if any of them is received rather than when the entire string of them
is received:</p>

<pre>
/* Read until comma or right brace is encountered. */
size_t nbytes = tcprecvuntil(conn, buf, sizeof(buf), ",}" , 2, -1);
</pre>

<h6>Cleaning up</h6>

<p>To close sockets (both listening and connected ones) use
<tt><a href="#tcpclose">tcpclose()</a></tt> function:</p>

<pre>
tcpclose(s);
</pre>

<h5 id="unix">UNIX</h5>

<p>Unix sockets are used for communicating between processes on the same
machine.</p>

<p>The API is identical to the <a href="#tcp">TCP API</a> with all <tt>tcp</tt>
prefixes replaced by <tt>unix</tt> prefixes. (For example <tt>unixsock</tt> or
<tt><a href="#unixrecv">unixrecv()</a></tt>.)</p>

<p>There are few minor adjustments to the API though.</p>

<p>Addresses passed to <tt><a href="#unixlisten">unixlisten()</a></tt> and
<tt><a href="#unixconnect">unixconnect()</a></tt> are names of a local
files rather than IP addresses. Also, there are no ports:</tt>

<pre>
unixsock s = unixconnect("/tmp/test.unix");
</pre>

Function <tt><a href="#unixpair">unixpair()</a></tt> creates a pair of connected
sockets. It's a wrapper on top of standard <tt>socketpair()</tt> function:</p>

<pre>
unixsock s1, s2;
unixpair(&s1, &s2);
</pre>

<h5 id="udp">UDP</h5>

<p>To open an UDP socket use <tt><a href="#udplisten">udplisten()</a></tt>
function. IP address of the local network interface should be supplied:</p>

<pre>
ipaddr addr = iplocal("192.168.0.111", 5555, 0);
udpsock s = udplisten(addr);
</pre>

<p>If port is set to zero operating system selects an unused port. The number
of the port can be retrieved using <tt><a href="#udpport">udpport()</a></tt>
function:</p>

<pre>
udpsock s = udplisten(addr);
int port = udpport(s);
</pre>

<p>Once the socket is open it can be immediately used for both sending and
receiving.</p>

<p>Given that UDP transport is unconnected by its very nature the address of
remote endpoint has to be specified in every
<tt><a href="#udpsend">udpsend()</a></tt> call. (Similarly, the IP address of
the remote endpoint is returned by each
<tt><a href="#udprecv">udprecv()</a></tt>call.)</p>

<pre>
ipaddr outaddr = ipremote("192.168.0.111", 5555, 0, -1);
udpsend(s, outaddr, "Hello, world!", 13);
...
char buf[256];
ipaddr inaddr;
size_t sz = udprecv(s, &inaddr, buf, sizeof(buf), -1);
</pre>

<p>Note that <tt><a href="#udpsend">udpsend()</a></tt> has no deadline. UDP
transport is unreliable and the packet is either delivered or lost, but never
blocked.</p>

<p>When done <a href="#udpclose">close</a> the UDP socket:</p>

<pre>
udpclose(s);
</pre>

<h4 id="clstorage">Coroutine-local storage</h4>

<p>Coroutine-local storage is an advanced mechanism meant to be used in
special cases. Avoid using it if possible. In general, use it where you would
use thread-local storage in a threaded program. TLS itself cannot be used with
libmill as multiple coroutines can share the same OS thread.</p>

<p>Coroutine local data are a single pointer which can be
<a href="#setcls">set</a> like this:</p>

<pre>
void *data = ...;
setcls(data);
</pre>

<p>Later on the pointer can be accessed anywhere within the coroutine or any
function invoked from it using <tt><a href="#cls">cls</a></tt> function:</p>

<pre>
void *data = cls();
</pre>

<p>It can be safely assumed that before coroutine-local data are set,
<tt><a href="#cls">cls</a></tt> function will return <tt>NULL</tt>.</p>

<h4 id="memory">Dealing with memory</h4>

<p>Most libmill functions report out of memory condition in the common way.
<tt><a href="#chmake">chmake()</a></tt> returns <tt>NULL</tt>,
<tt><a href="#tcplisten">tcplisten()</a></tt> returns <tt>NULL</tt> and sets
<tt>errno</tt> to <tt>ENOMEM</tt> and so on.</p>

<p>There's one exception though. Namely, if there's not enough memory to
allocate call stack for a new coroutine runtime panic happens and the process
is terminated.</p>

<p>If you wish to prevent that from happening you can allocate the coroutine
stacks in advance, typically when the process is starting, using
<tt><a href="#goprepare">goprepare()</a></tt> function.</p>

<p>Specify the number of coroutine stacks to preallocate, their size
in bytes and, additionally, the size of the biggest element you are going to
pass through libmill channels:</p>

<pre>
goprepare(100, 100000, 128);
</pre>

<p>From that point on your program shouldn't fail when launching a coroutine.
However, if you launch more parallelly running coroutines than allocated
or pass a bigger element than specified through a channel, memory allocations
will start happening again and all bets are off.</p>

<p>NOTE: On some systems (e.g. Linux) memory overcommit is switched on by
default. On such systems your application may be selected to be killed in low
memory conditions without you having any say in it. If you can't guarantee that
memory overcommit will be switched off when running the program don't even
bother with the measures described above.</p>

<h4 id="multiprocessing">Multiprocessing</h4>

<p>Libmill is intended for writing single-threaded applications. If you want
to take advantage of multi-core machines follow the UNIX way and use
multiprocessing.</p>

<p>An example can be found <a href="tutorial.html#step7">here</a>.</p>

<h4 id="debug">Debugging</h4>

<p>Libmill provides a couple of functions to help with the debugging. They can
be invoked either directly from the program or manually from the debugger.</p>

<p>When inspecting debug output following rules apply:</>

<ol>
  <li>Both coroutines and channels are represented by decimal IDs.</li>
  <li>The IDs are never re-used, even if the original object was already
      deallocated.</li>
  <li>Coroutine IDs are printed in curly braces, e.g. <tt>{24}</tt>.</li>
  <li>Channel IDs are printed in pointy braces, e.g. <tt>&lt;24&gt;</tt>.</li>
</ol>

<h5>goredump</h5>

<p>When debugging a program you may want to inspect the coroutines being
run and the channels being used. Use <tt><a href="#goredump">goredump()</a></tt>
function to do exactly that.</p>

<p>Here's an example of how to use it directly from a <tt>gdb</tt>
session:</p>

<pre>
Breakpoint 1, main () at foo.c:57
57	    if(quux &lt; 0) {
(gdb) p goredump()

COROUTINE  state                  current           created
----------------------------------------------------------------------
{0}        RUNNING                ---               &lt;main&gt;
{7}        chs(&lt;7&gt;)               foo.c:63          foo.c:157
{8}        chr(&lt;8&gt;)               foo.c:63          foo.c:158
{14}       choose(&lt;14&gt;,&lt;14&gt;)      foo.c:70          foo.c:258
{15}       ready                  foo.c:35          foo.c:276

CHANNEL  msgs/max    senders/receivers     refs  done  created
----------------------------------------------------------------------
&lt;7&gt;      0/0         s:{7}                 2     no    foo.c:155
&lt;8&gt;      0/0         r:{8}                 2     no    foo.c:156
&lt;14&gt;     0/0         s:{14},{14}           2     no    foo.c:257
&lt;15&gt;     22/100                            1     yes   foo.c:274

$2 = void
(gdb) 
</pre>

<p>The first section is coroutine dump. It contains the list of all coroutines,
each accompanied by its ID, state, the line of code that's it is executing at
the moment and to the line that originally created the coroutine.</p>

<p>The dump doesn't contain coroutine name. To map the coroutine record to
the actual coroutine in the code, check the line referenced by 'created'
field.</p>

<p>The 'state' field gives you more information about the operation being
performed. When a coroutine is blocked in <tt><a href="#chr">chr()</a></tt>
call, for example, you'll also see the ID of the channel it is trying to receive
from:</p>

<pre>
COROUTINE  state                  current           created
----------------------------------------------------------------------
{8}        chr(&lt;8&gt;)               foo.c:63          foo.c:158
</pre>

<p>When <tt><a href="#choose">choose</a></tt> statement is being executed a list
of channel IDs is provided, corresponding to the list of clauses in the
<tt><a href="#choose">choose</a></tt> statement:</p>

<pre>
COROUTINE  state                  current           created
----------------------------------------------------------------------
{14}       choose(&lt;5&gt;,&lt;3&gt;)        foo.c:22          foo.c:107
</pre>

<p>If there are any channels created by the user coroutine dump will be followed
by a channel dump. Each record in the dump corresponds to one channel instance
and contains its ID, number of messages buffered in the channel, channel
capacity, its reference count, whether <tt><a href="#chdone">chdone()</a></tt>
was already called and a the line of code that created the channel.</p> 

<p>Additionally, if there are any coroutines waiting for messages from the
channel -- whether via <tt><a href="#chr">chr</a></tt> or
<tt><a href="#choose">choose</a></tt> -- they are reported like this:</p>

<pre>
CHANNEL  msgs/max    senders/receivers     refs  done  created
----------------------------------------------------------------------
&lt;1&gt;      0/0         r:{4},{5}             2     no    foo.c:391
</pre>

<p>The waiting coroutines are served in the displayed order, i.e. when a new
message is sent to the channel it will be dispatched to coroutine 4. Next one
will go to coroutine 5 and so on.</p>

<p>Similarly, if there are coroutines trying to send message to the channel
but unable to do so becuase the channel's buffer if full they are reported in
the following way:</p>

<pre>
CHANNEL  msgs/max    senders/receivers     refs  done  created
----------------------------------------------------------------------
&lt;1&gt;      100/100     r:{2},{13}            2     no    foo.c:392
</pre>

<p>If there are no coroutines waiting to send or receive messages from the
channel the field is kept empty.</p>

<h5>gotrace</h5>

<p>It is possible to switch on tracing via
<tt><a href="#gotrace">gotrace()</a></tt> function. You can do so either
programmatically or from the debugger:</p>

<pre>
gotrace(1);
</pre>

<p>The function takes a single argument, the desired tracing level.
At the moment there are only two supported tracing levels:</p>

<ul>
  <li>0: tracing is off; this is the default value.</li>
  <li>1: invocations of all libmill functions are traced.</li>
</ul>

<p>Trace records are written to <tt>stderr</tt>. That way it is possible to
redirect the trace records to a file, while keeping the original output of the
program in the console:</p>

<pre>
$ ./test 2> trace.log
</pre>

<p>A part of the trace may look, for example, like this:</p>

<pre>
==> 22:24:56.404183 {0}      &lt;1&gt;=chmake(0) at tests/choose.c:113
==> 22:24:56.404276 {0}      {1}=go() at tests/choose.c:114
==> 22:24:56.404292 {1}      chdup(&lt;1&gt;) at tests/choose.c:114
==> 22:24:56.404304 {1}      chr(&lt;1&gt;) at tests/choose.c:30
==> 22:24:56.404316 {0}      choose() at tests/choose.c:115
==> 22:24:56.404354 {0}      chclose(&lt;1&gt;) at tests/choose.c:120
</pre>

<p>Each trace record contains timestamp, ID of the coroutine that have generated
the trace, the function being executed along with its arguments and the location
of its invocation in the source code.</p>

<p>The format is designed to be machine-friendly and, more specifically,
grep-friendly.</p>

<p>If you have a file that mixes trace records with other output, grep will
help you filter out the trace records:</p>

<pre>
$ grep "==>" trace.log
</pre>

<p>Similarly, you can filter out records related to a particular coroutine
or a specific channel:</p>

<pre>
$ grep "{9}" trace.log
$ grep "&lt;33&gt;" trace.log
</pre>

<h3 id="reference">Reference</h3>

<h6 id="chclose">void chclose(chan ch);</h6>

<p>Closes a channel handle. After last copy of the handle (see
<tt><a href="#chdup">chdup()</a></tt>) is closed, channel is deallocated.</p>

<p>Keep in mind that deallocation of a channel works very much like deallocation
of local variables when function returns. The memory holding the variable itself
won't leak, however, if the variable contains a pointer to a different object
that one doesn't get deallocated.</p>

<p>The function cannot fail.</p>

<h6 id="chdone">void chdone(chan ch, type, type value);</h6>

<p>This function is used to announce that the sender will send no more messages
to the channel.</p>

<p>First argument is the handle to the channel. Second one is type of the
termination message and last one is the termination message itself. The type
of the message must match the type of the channel otherwise the program will
panic and abort.</p>

<p>When all messages are retrieved from the channel, all the receivers will
receive the termination message over and over again.</p>

<p>The function cannot fail.</p>

<h6 id="chdup">chan chdup(chan ch);</h6>

<p>Duplicates channel handle. Channel gets deallocated only after all its
handles are closed using <tt><a href="#chclose">chclose()</a></tt> function.</p>

<p>The function returns duplicated channel handle and cannot fail.</p>

<h6 id="chmake">chan chmake(type, size);</h6>

<p>Creates a channel. First parameter is the type of the items to be sent
through the channel. Second parameter is number of items that will fit into the
channel. Setting this argument to zero creates an unbuffered channel.</p>

<p>The function returns channel handle or NULL in case there's not enough
memory to allocate the channel.</p>

<h6 id="choose">choose {}</h6>

<p>Waits for activity on multiple channels.</p>

<p>The statement consists of multiple clauses. Last clause must always be
<tt>end</tt>:</p>

<pre>
choose {
in(ch1, int, i):
    foo(i);
in(ch2, int, i):
    bar(i);
out(ch3, int, 42):
    baz();
otherwise:
    quux();
end
}
</pre>

<p><tt>in</tt> clause waits for a message coming from a channel. It accepts
three arguments. The channel to receive the message from, the type of the
message and the variable to assign the message to.</p>

<p>The variable is declared by the clause, you don't have to declare it
beforehand yourself.</p>

<p>If message type doesn't match the channel type program will panic and
abort.</p>

<p><tt>out</tt> clause waits until a message can be sent to a channel. It may
not be immediately possible as the channel may be full. The clause accepts
three arguments. The channel to send the message to, the type of the message
and the message itself.</p>

<p>If message type doesn't match the channel type program will panic and
abort.</p>

<p><tt>deadline</tt> clause will be executed if deadline expires while waiting
for other clauses. For example:</p>

<pre>
choose {
in(ch1, int, i):
    foo(i);
deadline(now() + 1000):
    printf("Deadline exceeded!\n");
end
}
</pre>

<p><tt>otherwise</tt> clause is run if no other clause can be executed
immediately. A <tt>choose</tt> statement with <tt>otherwise</tt> clause
therefore never blocks.</p>

<p><tt>deadline</tt> and <tt>otherwise</tt> clause are mutually exclusive and
neither of them can occur multiple times.</p>

<p>If multiple clauses can be executed immediately, one of them is chosen
at random.</p>

<p>There's no fall-through among the clauses. In other words, there's no need
to put <tt>break</tt> at the end of each clause as is the case with standard
C <tt>switch</tt> statement.</p>

<p>If <tt>break</tt> statement is used it will break out of the <tt>choose</tt>
construct nonetheless. Behaviour of <tt>continue</tt> statement within
<tt>choose</tt> is undefined.</p>

<p>The construct returns no errors.</p>

<h6 id="chr">type chr(chan ch, type);</h6>

<p>Retrieves a message from the channel. First parameter is the channel handle,
second one is the type of the message. The type specified must match the type of
the channel otherwise the program will panic and abort.</p>

<p>If there's no message in the channel the function waits until one becomes
available.</p>

<p>Retrieved message is returned from the function. It cannot fail.</p>

<h6 id="chs">void chs(chan ch, type, type value);</h6>

<p>Send a message to the channle. First parameter is the channel handle, second
one is the type of the message and third one is the message itself. If the type
of the message doesn't match the type of the channel the program will panic and
abort.</p>

<p>If there's no space in the channel for the message the function waits until
it becomes available.</p>

<p>Sending to a channel that was previously terminated using
<tt><a href="#chdone">chdone()</a></tt> function results in runtime panic.</p>

<p>The function cannot fail.</p>

<h6 id="cls">void *cls(void);</h6>

<p>Returns coroutine-local storage, a single pointer that is accessible
from anywhere within the same coroutine.</p>

<p>You can set the coroutine-local storage using
<a href="#setcls"><tt>setcls()</tt></a> function. If it was not previously
set <tt>cls()</tt> will return <tt>NULL</tt>.</p>

<p>The function cannot fail.</p>

<h6 id="coroutine">coroutine</h6>

<p>A specifier that must be added to all functions that are executed using
<a href="#go"><tt>go()</tt></a>, for example:

<pre>
coroutine void foo(int i);
</pre>

<p>Be aware that programs typically work even without <tt>coroutine</tt>
specifier, however, they may fail in random fashion, depending on a particular
combination of compiler, optimisation level and code in question.</p>

<h6 id="fdclean">void fdclean(int fd);</h6>

<p>This function drops any cached state associated with the file descriptor.
It has to be called before the file descriptor is closed. If it is not,
undefined behaviour may ensue.</p>

<p>It should also be used when you are temporarily provided with a file
descriptor by a third party library, just before returning the descriptor
back to the original owner.</p>

<p><tt>tcpsock</tt>, <tt>unixsock</tt> and <tt>udpsock</tt> take care of
calling this function, so unless you are creating custom file descriptors
by hand, you don't have to care.</p>

<p>The function cannot fail.</p>

<h6 id="fdwait">int fdwait(int fd, int events, int64_t deadline);</h6>

<p>Waits for an event from a file descriptor.</p>

<p>The arguments are the file descriptor, the events to wait for and the
<a href="#deadlines">deadline</a>.</p>

<pre>
int events = fdwait(fd, FDW_IN | FDW_OUT, -1);
</pre>

<ul>
<li>FDW_IN: Wait until data can be received from the file descriptor.</li>
<li>FDW_OUT: Wait until data can de sent to the file descriptor.</li>
</ul>

<tt>fdwait</tt> returns combination of following flags:</p>

<ul>
<li>FDW_IN: Data can be received from the file descriptor.</li>
<li>FDW_OUT: Data can be sent to the file descriptor.</li>
<li>FDW_ERR: Error occured.</li>
</ul>

<p>Note that <tt>FDW_ERR</tt> cannot be used as an argument to
the function, but it can be returned irrespective of whether the caller asked
for it or not.</p>

<p>If an error happens while there are still data to be received from the
file descriptor combination of <tt>FDW_ERR</tt> and <tt>FDW_IN</tt> may be
returned.</p>

<p>If deadline is reached while waiting for the file descriptor,
zero is returned.</p>

<h6 id="go">void go(expression);</h6>

<p>Launches a coroutine that executes the function passed in
the <tt>expression</tt> argument, for example:

<pre>
go(foo(42));
</pre>

<p>Coroutine is executed in concurrent manner and its lifetime may
exceed the lifetime of the caller. Therefore, the return value of the function
is discarded and cannot be retrieved by the caller.</p>

<p>Any function to be invoked unsing <tt>go()</tt> must be declared with
<tt><a href="#coroutine">coroutine</a></tt> specifier.</p>

<p>Be aware that programs typically work even without <tt>coroutine</tt>
specifier, however, they may fail in random fashion, depending on a particular
combination of compiler, optimisation level and code in question.</p>

<p>If there is not enough memory to allocate new stack for the coroutine,
<tt>go()</tt> aborts the process. To avoid that happening you can pre-allocate
the stacks on process startup using
<tt><a href="#goprepare">goprepare()</a></tt>.</p>

<h6 id="goprepare">void goprepare(int count, size_t stack_size, size_t val_size);</h6>

<p>Preallocate coroutine stacks. This function is useful to guarantee that
coroutine invocation won't fail when there's insufficient memory to allocate
the stack.</p>

<p>NOTE: On some systems (e.g. Linux) memory overcommit is switched on by
default. On such systems your application may be selected to be killed in low
memory conditions without program having any say in it. If you can't guarantee
that memory overcommit will be switched off then using <tt>goprepare()</tt> has
basically zero effect.</p>

<p>The arguments are number of coroutine stacks to preallocate, their size
in bytes and, additionally, the size of the biggest element you are going to
pass through libmill channels:</p>

<pre>
goprepare(100, 100000, 128);
</pre>

<p>Program can use up to the specified number of coroutines in parallel without
the need for memory allocation. However, if the limit is reached -- or if
message larger than <tt>val_size</tt> is sent through a channel -- memory
allocation may occur, fail and cause panic and termination of the process.</p>

<p>Additionally, the function preallocates any process-wide resources needed,
   such as, for example, global pollsets.</p>

<p>The function sets <tt>errno</tt> to zero in case of success or to one of
the following errors otherwise:</p>

<ul style="list-style: none;">
  <li><tt>EAGAIN</tt>: There are coroutines running. The stacks can't be
      reallocated.</li>
  <li><tt>EMFILE</tt>: The maximum number of file descriptors in the process are
      already open.</li>
  <li><tt>ENFILE</tt>: The maximum number of file descriptors in the system are
      already open.</li>
  <li><tt>ENOMEM</tt>: Not enough memory to allocate the stacks.</li>
</ul>

<h6 id="goredump">void goredump(void);</h6>

<p>Dumps current state of all coroutines and all channels to
<tt>stderr</tt>.</p>

<p>The function can be launched either from the program of from the debugger.
</p>

<p>For more information look <a href="#debug">here</a>.</p>

<h6 id="gotrace">void gotrace(int level);</h6>

<p>Sets the tracing level.</p>

<p>The function can be launched either from the program of from the debugger.
</p>

<p>For more information look <a href="#debug">here</a>.</p>

<h6 id="ipaddrstr">const char *ipaddrstr(ipaddr addr, char *buffer);</h6>

<p>Formats <tt>ipaddr</tt> as human-readable string.</p>

<p>First argument is the IP address to format, second is the buffer to store
the result it. The buffer must be at least <tt>IPADDR_MAXSTRLEN</tt> bytes
long.</p>

<p>The function returns pointer to the formatted string.</p>

<h6 id="iplocal">ipaddr iplocal(const char *name, int port, int mode);</h6>

<p>Converts an IP address in human-readable format, or a name of a local network
interface, into an <tt>ipaddr</tt> object:</p>

<pre>
ipaddr a1 = iplocal("127.0.0.1", 3333, 0);
ipaddr a2 = iplocal("::1", 4444, 0);
ipaddr a3 = iplocal("eth0", 5555, 0);
</pre>

<p>First argument is the string to convert. Second argument is the port number.
Third argument specifies which kind of addresses should be returned. Possible
values are:</p>

<ul>
  <li><pp>IPADDR_IPV4</pp>: get IPv4 address or error if it's not available</li>
  <li><pp>IPADDR_IPV6</pp>: get IPv6 address or error if it's not available</li>
  <li><pp>IPADDR_PREF_IPV4</pp>: get IPv4 address if possible, IPv6 address
          otherwise; error if none is available</li>
  <li><pp>IPADDR_PREF_IPV6</pp>: get IPv6 address if possible, IPv4 address
          otherwise; error if none is available</li>
</ul>

<p>Setting the argument to zero invokes default behaviour, which, at the
present, is <pp>IPADDR_PREF_IPV4</pp>. However, in the future when IPv6 becomes
more common it may be switched to <pp>IPADDR_PREF_IPV6</pp>.</p>

<p>If address parameter is set to NULL, INADDR_ANY or in6addr_any is returned.
This value is useful when binding to all local network interfaces.</p>

<p>In case of error <tt>errno</tt> is set to appropriate error code, as
indicated below. Returned address will then have family type of AF_UNSPEC which
in turn will cause any function you pass it to fail with <tt>EAFNOSUPPORT</tt>
error.</p>

<p>As the functionality is not covered by POSIX and rather implemented by
OS-specific means there's no definitive list of possible error codes the
function can return. You have to make the error handling as generic as
possible.</p>

<h6 id="ipremote">ipaddr ipremote(const char *name, int port, int mode, int64_t deadline);</h6>

<p>Converts an IP address in human-readable format, or a name of a remote host
into an <tt>ipaddr</tt> object:</p>

<pre>
ipaddr a1 = ipremote("192.168.0.111", 5555, 0, -1);
ipaddr a2 = ipremote("www.expamle.org", 80, 0, -1); 
</pre>

<p>First argument is the string to convert. Second argument is the port number.
Third argument specifies which kind of addresses should be returned. Possible
values are:</p>

<ul>
  <li><pp>IPADDR_IPV4</pp>: get IPv4 address or error if it's not available</li>
  <li><pp>IPADDR_IPV6</pp>: get IPv6 address or error if it's not available</li>
  <li><pp>IPADDR_PREF_IPV4</pp>: get IPv4 address if possible, IPv6 address
          otherwise; error if none is available</li>
  <li><pp>IPADDR_PREF_IPV6</pp>: get IPv6 address if possible, IPv4 address
          otherwise; error if none is available</li>
</ul>

<p>Setting the argument to zero invokes default behaviour, which, at the
present, is <pp>IPADDR_PREF_IPV4</pp>. However, in the future when IPv6 becomes
more common it may be switched to <pp>IPADDR_PREF_IPV6</pp>.</p>

<p>Finally, the fourth argument is the <a href="#deadlines">deadline</a>. It
allows to deal with situations where resolving a remote host name requires a DNS
query and the query is taking substantial amount of time to complete.</p>

<p>In case of error <tt>errno</tt> is set to appropriate error code, as
indicated below. Returned address will then have family type of AF_UNSPEC which
in turn will cause any function you pass it to fail with <tt>EAFNOSUPPORT</tt>
error.</p>

<p>As the functionality is not covered by POSIX and rather implemented by
OS-specific means there's no definitive list of possible error codes the
function can return. You have to make the error handling as generic as
possible.</p>

<h6 id="mfclose">void mfclose(mfile f);</h6>

<h6 id="mfeof">int mfeof(mfile f);</h6>

<h6 id="mferr">mferr</h6>

<p><tt>mfile</tt> wrapper on top of stderr.</p>

<h6 id="mfflush">void mfflush(mfile f, int64_t deadline);</h6>

<h6 id="mfin">mfin</h6>

<p><tt>mfile</tt> wrapper on top of stdin.</p>

<h6 id="mfopen">mfile mfopen(const char *pathname, int flags, mode_t mode);</h6>

<h6 id="mfork">pid_t mfork(void);</h6>

<p>This function is a wrapper on top od the standard POSIX <tt>fork()</tt>
function. In addition to forking the process it properly detaches libmill's
internal resources (such as any kernel-side kqueue/epoll pollsets) in child
process from those in the parent process.</p>

<p>Using <tt>fork()</tt> instead of <tt>mfork()</tt> results in undefined
behaviour.</p>

<p>The function returns the process ID of the newly created process to the
parent process, zero to the child process or -1 in case of error. In the latter
case it also sets <tt>errno</tt> to the appropriate error code.</p>

<h6 id="mfout">mfout</h6>

<p><tt>mfile</tt> wrapper on top of stdout.</p>

<h6 id="mfread">size_t mfread(mfile f, void *buf, size_t len, int64_t deadline);</h6>

<h6 id="mfseek">off_t mfseek(mfile f, off_t offset);</h6>

<h6 id="mftell">off_t mftell(mfile f);</h6>

<h6 id="mfwrite">mfwrite(mfile f, const void *buf, size_t len, int64_t deadline);</h6>

<h6 id="msleep">void msleep(int64_t deadline);</h6>

<p>Waits until the <tt><a href="#deadlines">deadline<a></tt>. Following
statement, for example, waits for one second:</p>

<pre>
msleep(now() + 1000);
</pre>

<p>The function returns no errors.</p>

<h6 id="now">int64_t now(void);</h6>

<p>Returns current time, in milliseconds.</p>

<p>The function is meant to be used for creating deadlines. For example,
a point of time one second on from now can be expressed as
<tt>now() + 1000</tt>.</p>

<p>Value of -1 cannot be returned from the function and is therefore used to
mean 'infinite'.</p>

<p>The function cannot fail.</p>

<h6 id="setcls">void setcls(void *val);</h6>

<p>Set coroutine-local storage, a single pointer that will be accessible
from anywhere within the same coroutine using <a href="#cls"><tt>cls()</tt></a>
function.</p>

<p>The function cannot fail.</p>

<h6 id="tcpaccept">tcpsock tcpaccept(tcpsock s, int64_t deadline);</h6>

<p>Accepts new incoming TCP connection from
<tt><a href="#tcplisten">listening</a></tt> socket <tt>s</tt>. Second argument
is the <tt><a href="#deadlines">deadline</a></tt> for the operation.</p>

<pre>
ipaddr addr = iplocal("127.0.0.1", 5555, 0);
tcpsock listener = tcplisten(addr, 10);
tcpsock connection = tcpaccept(listener, -1);
</pre>

<p>If the function succeeds it returns handle of the newly created connection
and sets <tt>errno</tt> to zero.</p>

<p>If the function fails it returns <tt>NULL</tt> and sets <tt>errno</tt> to
one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>ECONNABORTED</tt>: A connection has been aborted.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>EMFILE</tt>: The maximum number of file descriptors in the process are
      already open.</li>
  <li><tt>ENFILE</tt>: The maximum number of file descriptors in the system are
      already open.</li>
  <li><tt>ENOBUFS</tt>: No buffer space is available.</li>
  <li><tt>ENOMEM</tt>: There was insufficient memory available to complete the
      operation.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline was reached.</li>
</ul>

<h6 id="tcpaddr">ipaddr tcpaddr(tcpsock s);</h6>

<p>After accepting an incoming TCP connection this function can be used to
retrieve the IP address of the peer.</p>

<p>The function cannot fail.</p>

<h6 id="tcpclose">void tcpclose(tcpsock s);</h6>

<p>Closes the socket.</p>

<p>The function always succeeds.</p>

<h6 id="tcpconnect">tcpsock tcpconnect(ipaddr addr, int64_t deadline);</h6>

<p>Creates a TCP connection to a remote endpoint.</p>

<p>First parameter is the IP address to connect to. Second one is the
<tt><a href="#deadlines">deadline</a></tt> for the operation.<p>

<pre>
ipaddr addr = ipremote("www.example.org", 80, 0, -1);
tcpsock connection = tcpconnect(addr, -1);
</pre>

<p>If the function succeeds it returns handle of the newly created connection
and sets <tt>errno</tt> to zero.</p>

<p>If the function fails it returns <tt>NULL</tt> and sets <tt>errno</tt> to
one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>ECONNREFUSED:</tt>The target address was not listening for connections
       or refused the connection request.</li>
  <li><tt>ECONNRESET</tt>: Remote host reset the connection request.</li>
  <li><tt>EHOSTUNREACH</tt>: The destination host cannot be reached.</li>
  <li><tt>ENETDOWN</tt>: The local network interface used to reach the
      destination is down.</li>
  <li><tt>ENETUNREACH</tt>: No route to the network is present.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>EMFILE</tt>: The maximum number of file descriptors in the process are
      already open.</li>
  <li><tt>ENFILE</tt>: The maximum number of file descriptors in the system are
      already open.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>ENOBUFS</tt>: No buffer space is available.</li>
  <li><tt>ENOMEM</tt>: There was insufficient memory available to complete the
      operation.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline was reached.</li>
</ul>

<h6 id="tcpflush">void tcpflush(tcpsock s, int64_t deadline);</h6>

<p>When using <tt><a href="#tcpsend">tcpsend()</a></tt> the library may choose
not to send the data for the moment. <tt>tcpflush()</tt> can be used to flush
any yet unsent data to the network.</p>

<p>First argument is the socket to flush, second one is the
<a href="#deadlines">deadline</a>.</p>

<p>In case of success, the function sets errno to zero. In case of failure it
sets it to one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>ECONNRESET</tt>: A connection was forcibly closed by a peer.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>EPIPE</tt>: The socket is shut down for writing.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>ENETDOWN</tt>: The local network interface used to reach the
      destination is down.</li>
  <li><tt>ENETUNREACH</tt>: No route to the network is present.</li>
  <li><tt>ENOBUFS</tt>: No buffer space is available.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline was reached.</li>
</ul>

<h6 id="tcplisten">tcpsock tcplisten(ipaddr addr, int backlog);</h6>

<p>Starts listening for incoming TCP connections.</p>

<p>First argument is the IP address to listen on (see
<tt><a href="#iplocal">iplocal()</a></tt>), second one is the connection
backlog size, i.e. maximum number of connections that weren't refused but
are not yet accepted.</p>

<pre>
ipaddr addr = iplocal("eth0", 5555, 0);
tcpsock listener = tcplisten(addr, 10);
</pre>

<p>If the IP address passed to the function has port number set to zero,
operating system will choose an ephemeral port to bind to. The number of the
chosen port can be later retrieved using
<tt><a href="#tcpport">tcpport()</a></tt> function.</p>

<p>In case of success <tt>tcplisten()</tt> returns handle to the listening
socket and sets <tt>errno</tt> to zero.</p>

<p>In case of failure it returns <tt>NULL</tt> and sets <tt>errno</tt> to one
of the following error codes:</p>

<ul style="list-style: none;">
  <li><tt>EADDRINUSE</tt>: The specified address is already in use.</li>
  <li><tt>EADDRNOTAVAIL</tt>: The specified address is not available from the
      local machine.</li>
  <li><tt>EMFILE</tt>: No more file descriptors are available for this
      process.</li>
  <li><tt>ENFILE</tt>: No more file descriptors are available for the
      system.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>ENOBUFS</tt>: Insufficient resources were available in the system to
      perform the operation.</li>
  <li><tt>ENOMEM</tt>: Insufficient memory was available to fulfill the
      request.</li>
</ul>

<h6 id="tcpport">int tcpport(tcpsock s);</h6>

<p>Returns TCP port used by the socket.</p>

<p>If <tt><a href="#tcplisten">tcplisten()</a></tt> was called with port number
set to zero, operating system chooses an ephemeral port for the connection.
This function can be used to retrieve the port number in that scenario.</p>

<p>The function cannot return error.</p>

<h6 id="tcprecv">size_t tcprecv(tcpsock s, void *buf, size_t len, int64_t deadline);</h6>

<p>Reads data from TCP connection.</p>

<p>First argument is the socket to read from. Second parameter is pointer to
the buffer to read the data to. Third argument is the size of the buffer.
Finally, fourth parameter is <a href="#deadlines">deadline</a> for the
operation.</p>

<pre>
char buf[256];
size_t nbytes = tcprecv(s, buf, sizeof(buf), -1);
</pre>

<p>In the case of success, <tt>errno</tt> is set to zero. In the case of failure
it is set to one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>ECONNRESET</tt>: A connection was forcibly closed by a peer.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>ENOBUFS</tt>: Insufficient resources were available in the system to
      perform the operation.</li>
  <li><tt>ENOMEM</tt>: Insufficient memory was available to fulfill the
      request.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline exceeded.</li>
</ul>

<p>The function returns number of bytes received.</p>

<h6 id="tcprecvuntil">size_t tcprecvuntil(tcpsock s, void *buf, size_t len, const char *delims, size_t delimcount, int64_t deadline);</h6>

<p>Reads data from TCP connection until either buffer is full or a delimiter
character is reached.</p>

<p>First argument is the socket to read from. Second parameter is pointer to
the buffer to read the data to. Third argument is the size of the buffer.</p>

<p><tt>delims</tt> parameter is a sequence of bytes any of which, if encountered
in the incoming data, will cause <tt>tcprecvuntil()</tt> to exit. Size of the
sequence, in bytes, is passed to the function in <tt>delimcount</tt> parameter.
</p>

<p>Finally, last parameter is <a href="#deadlines">deadline</a> for the
operation.</p>

<p>For example, following example reads data until either comma or newline
character is encountered:</p>

<pre>
char buf[256];
size_t nbytes = tcprecvuntil(s, buf, sizeof(buf), ",\n", 2, -1);
</pre>

<p>In the case of success, <tt>errno</tt> is set to zero. In the case of failure
it is set to one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>ECONNRESET</tt>: A connection was forcibly closed by a peer.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>ENOBUFS</tt>: Insufficient resources were available in the system to
      perform the operation.</li>
  <li><tt>ENOMEM</tt>: Insufficient memory was available to fulfill the
      request.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline exceeded.</li>
</ul>

<p>The function returns number of bytes received including the delimiter
character.</p>

<h6 id="tcpsend">size_t tcpsend(tcpsock s, const void *buf, size_t len, int64_t deadline);</h6>

<p>Sends data to TCP connection.</p>

<p>First argument is the socket handle to send the data to. Second argument is
pointer to the buffer to send. Third argument is the size of the buffer,
in bytes. Finally, fourth argument is the
<tt><a href="#deadlines">deadline</a></tt>.</p>

<pre>
size_t nbytes = tcpsend(s, "ABC", 3, -1);
</pre>

<p>In the case of success, <tt>errno</tt> is set to zero. In the case of
failure it is set to one of the following error codes:</p>

<ul style="list-style: none;">
  <li><tt>ECONNRESET</tt>: A connection was forcibly closed by a peer.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>EPIPE</tt>: The socket is shut down for writing.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>ENETDOWN</tt>: The local network interface used to reach the
      destination is down.</li>
  <li><tt>ENETUNREACH</tt>: No route to the network is present.</li>
  <li><tt>ENOBUFS</tt>: No buffer space is available.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline was reached.</li>
</ul>

<p>Whether successful or not, the function returns number of bytes actually
written to the socket.</p>

<p>To optimise the throughput <tt>tcpsend()</tt> may store the data into output
buffer and not flush it into the network immediately. To force sending of the
data use <tt><a href="#tcpflush">tcpflush()</a></tt> function.</p>

<h6 id="udpclose">void udpclose(udpsock s);</h6>

<p>Closes the socket.</p>

<p>The function always succeeds.</p>

<h6 id="udplisten">udpsock udplisten(ipaddr addr);</h6>

<p>Creates an UDP socket and starts listening for incoming packets.</p>

<p>The argument is the IP address to listen on (see
<tt><a href="#iplocal">iplocal()</a></tt>).</p>

<pre>
ipaddr addr = iplocal("eth0", 5555, 0);
udpsock s = udplisten(addr);
</pre>

<p>If the IP address passed to the function has port number set to zero,
operating system will choose an ephemeral port to bind to. The number of the
chosen port can be later retrieved using
<tt><a href="#udpport">udpport()</a></tt> function.</p>

<p>In case of success <tt>udplisten()</tt> returns handle to the listening
socket and sets <tt>errno</tt> to zero.</p>

<p>In case of failure it returns <tt>NULL</tt> and sets <tt>errno</tt> to one
of the following error codes:</p>

<ul style="list-style: none;">
  <li><tt>EADDRINUSE</tt>: The specified address is already in use.</li>
  <li><tt>EADDRNOTAVAIL</tt>: The specified address is not available from the
      local machine.</li>
  <li><tt>EMFILE</tt>: No more file descriptors are available for this
      process.</li>
  <li><tt>ENFILE</tt>: No more file descriptors are available for the
      system.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>ENOBUFS</tt>: Insufficient resources were available in the system to
      perform the operation.</li>
  <li><tt>ENOMEM</tt>: Insufficient memory was available to fulfill the
      request.</li>
</ul>

<h6 id="udpport">int udpport(udpsock s);</h6>

<p>Returns UDP port used by the socket.</p>

<p>If <tt><a href="#udplisten">udplisten()</a></tt> was called with port number
set to zero, operating system chooses an ephemeral port to listen on.
<tt>udpport()</tt> function can be used to retrieve the port number in that
scenario.</p>

<p>The function cannot return error.</p>

<h6 id="udprecv">size_t udprecv(udpsock s, ipaddr *addr, void *buf, size_t len, int64_t deadline);</h6>

<p>Receives an UDP datagram.</p>

<p>First argument is the socket to receive from. Second parameter is an out
parameter. If the call succeeds it will hold the source IP address of the
datagram. Third argument is the buffer to read the data to. Fourth is the size
of the buffer. Last parameter is <a href="#deadlines">deadline</a> for the
operation.</p>

<pre>
ipaddr addr;
char buf[256];
size_t nbytes = udprecv(s, &addr, buf, sizeof(buf), -1);
</pre>

<p>In the case of success, <tt>errno</tt> is set to zero. In the case of failure
it is set to one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>ENOBUFS</tt>: Insufficient resources were available in the system to
      perform the operation.</li>
  <li><tt>ENOMEM</tt>: Insufficient memory was available to fulfill the
      request.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline exceeded.</li>
</ul>

<p>The function returns number of bytes in the datagram or zero if no datagram
was received.</p>


<h6 id="udpsend">void udpsend(udpsock s, ipaddr addr, const void *buf, size_t len);</h6>

<p>Sends an UDP datagram.</p>

<p>First argument is the socket handle to send the data to. Second argument is
the IP address to the datagram to. Third argument points to the data to send.
Fourth argument is the size of the buffer, in bytes.</p>

<pre>
ipaddr addr = ipremote("192.168.0.111", 5555, 0, -1);
udpsend(s, addr, "Hello, world!", 13);
</pre>

<p>In the case of success, <tt>errno</tt> is set to zero. In the case of
failure it is set to one of the following error codes:</p>

<ul style="list-style: none;">
  <li><tt>EMSGSIZE</tt>: The message is too large to be sent all at once.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>ENETDOWN</tt>: The local network interface used to reach the
      destination is down.</li>
  <li><tt>ENETUNREACH</tt>: No route to the network is present.</li>
  <li><tt>ENOBUFS</tt>: No buffer space is available.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline was reached.</li>
</ul>

<h6 id="unixaccept">unixsock unixaccept(unixsock s, int64_t deadline);</h6>

<p>Accepts new incoming UNIX domain connection from
<tt><a href="#unixlisten">listening</a></tt> socket <tt>s</tt>. Second argument
is the <tt><a href="#deadlines">deadline</a></tt> for the operation.</p>

<pre>
unixsock listener = unixlisten("/tmp/test.unix", 10);
unixsock connection = unixaccept(listener, -1);
</pre>

<p>If the function succeeds it returns handle of the newly created connection
and sets <tt>errno</tt> to zero.</p>

<p>If the function fails it returns <tt>NULL</tt> and sets <tt>errno</tt> to
one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>ECONNABORTED</tt>: A connection has been aborted.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>EMFILE</tt>: The maximum number of file descriptors in the process are
      already open.</li>
  <li><tt>ENFILE</tt>: The maximum number of file descriptors in the system are
      already open.</li>
  <li><tt>ENOBUFS</tt>: No buffer space is available.</li>
  <li><tt>ENOMEM</tt>: There was insufficient memory available to complete the
      operation.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline was reached.</li>
</ul>

<h6 id="unixclose">void unixclose(unixsock s);</h6>

<p>Closes the socket.</p>

<p>The function always succeeds.</p>

<h6 id="unixconnect">unixsock unixconnect(const char *addr);</h6>

<p>Creates a UNIX domain connection to a remote endpoint.</p>

<p>The parameter is the file to connect to.<p>

<pre>
unixsock connection = unixconnect("/tmp/test.unix");
</pre>

<p>If the function succeeds it returns handle of the newly created connection
and sets <tt>errno</tt> to zero.</p>

<p>If the function fails it returns <tt>NULL</tt> and sets <tt>errno</tt> to
one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>ECONNREFUSED:</tt>The target address was not listening for connections
       or refused the connection request.</li>
  <li><tt>ECONNRESET</tt>: Remote host reset the connection request.</li>
  <li><tt>EIO</tt>: An I/O error occurred while reading from or writing to the
      file system.</li>
  <li><tt>ELOOP</tt>: A loop exists in symbolic links encountered during
      resolution of the pathname in address.</li>
  <li><tt>ENAMETOOLONG</tt>: A component of a pathname exceeded
      <tt>NAME_MAX</tt> characters, or an entire pathname exceeded
      <tt>PATH_MAX</tt> characters.</li>
  <li><tt>ENOENT</tt>: A component of the pathname does not name an existing
      file or the pathname is an empty string.</li>
  <li><tt>ENOTDIR</tt>: A component of the path prefix of the pathname in
      address is not a directory.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>EMFILE</tt>: The maximum number of file descriptors in the process are
      already open.</li>
  <li><tt>ENFILE</tt>: The maximum number of file descriptors in the system are
      already open.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>ENOBUFS</tt>: No buffer space is available.</li>
  <li><tt>ENOMEM</tt>: There was insufficient memory available to complete the
      operation.</li>
</ul>

<h6 id="unixflush">void unixflush(unixsock s, int64_t deadline);</h6>

<p>When using <tt><a href="#unixsend">unixsend()</a></tt> the library may choose
not to send the data for the moment. <tt>unixflush()</tt> can be used to flush
any yet unsent data.</p>

<p>First argument is the socket to flush, second one is the
<a href="#deadlines">deadline</a>.</p>

<p>In case of success, the function sets errno to zero. In case of failure it
sets it to one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>ECONNRESET</tt>: A connection was forcibly closed by a peer.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>EPIPE</tt>: The socket is shut down for writing.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>EIO</tt>: An I/O error occurred while reading from or writing to the
      file system.</li>
  <li><tt>ENOBUFS</tt>: No buffer space is available.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline was reached.</li>
</ul>

<h6 id="unixlisten">unixsock unixlisten(const char *addr, int backlog);</h6>

<p>Starts listening for incoming UNIX domain connections.</p>

<p>First argument is the file to listen on second one is the connection
backlog size, i.e. maximum number of connections that weren't refused but
are not yet accepted.</p>

<pre>
unixsock listener = unixlisten("/tmp/test.unix", 10);
</pre>

<p>In case of success <tt>unixlisten()</tt> returns handle to the listening
socket and sets <tt>errno</tt> to zero.</p>

<p>In case of failure it returns <tt>NULL</tt> and sets <tt>errno</tt> to one
of the following error codes:</p>

<ul style="list-style: none;">
  <li><tt>EDESTADDRREQ or EISDIR</tt>: The address argument is a null
      pointer.</li>
  <li><tt>EIO</tt>: An I/O error occurred.</li>
  <li><tt>ELOOP</tt>: A loop exists in symbolic links encountered during
      resolution of the pathname in address.</li>
  <li><tt>ENAMETOOLONG</tt>: A component of a pathname exceeded
      <tt>NAME_MAX</tt> characters, or an entire pathname exceeded
      <tt>PATH_MAX</tt> characters.</li>
  <li><tt>ENOENT</tt>: A component of the pathname does not name an existing
      file or the pathname is an empty string.</li>
  <li><tt>ENOTDIR</tt>: A component of the path prefix of the pathname in
      address is not a directory.</li>
  <li><tt>EROFS</tt>: The name would reside on a read-only file system.</li>
  <li><tt>EADDRINUSE</tt>: The specified address is already in use.</li>
  <li><tt>EMFILE</tt>: No more file descriptors are available for this
      process.</li>
  <li><tt>ENFILE</tt>: No more file descriptors are available for the
      system.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>ENOBUFS</tt>: Insufficient resources were available in the system to
      perform the operation.</li>
  <li><tt>ENOMEM</tt>: Insufficient memory was available to fulfill the
      request.</li>
</ul>

<h6 id="unixpair">void unixpair(unixsock *a, unixsock *b);</h6>

<p>Creates a pair of mutually connected UNIX domain sockets.</p>

<p>The arguments are pointers to two uninitialised <tt>unixsock</tt>
handles.</p>

<p>If the function succeeds it sets <tt>errno</tt> to zero.</p>

<p>If it fails it sets it to one of the following error codes:</p>

<ul style="list-style: none;">
  <li><tt>EINVAL</tt>: One or both arguments are <tt>NULL</tt>.</li>
  <li><tt>EMFILE</tt>: The maximum number of file descriptors in the process are
      already open.</li>
  <li><tt>ENFILE</tt>: The maximum number of file descriptors in the system are
      already open.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>ENOBUFS</tt>: No buffer space is available.</li>
  <li><tt>ENOMEM</tt>: There was insufficient memory available to complete the
      operation.</li>
</ul>

<h6 id="unixrecv">size_t unixrecv(unixsock s, void *buf, size_t len, int64_t deadline);</h6>

<p>Reads data from UNIX domain connection.</p>

<p>First argument is the socket to read from. Second parameter is pointer to
the buffer to read the data to. Third argument is the size of the buffer.
Finally, fourth parameter is <a href="#deadlines">deadline</a> for the
operation.</p>

<pre>
char buf[256];
size_t nbytes = unixrecv(s, buf, sizeof(buf), -1);
</pre>

<p>In the case of success, <tt>errno</tt> is set to zero. In the case of failure
it is set to one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>ECONNRESET</tt>: A connection was forcibly closed by a peer.</li>
  <li><tt>EIO</tt>: An I/O error occurred.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>ENOBUFS</tt>: Insufficient resources were available in the system to
      perform the operation.</li>
  <li><tt>ENOMEM</tt>: Insufficient memory was available to fulfill the
      request.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline exceeded.</li>
</ul>

<p>The function returns number of bytes received.</p>

<h6 id="unixrecvuntil">size_t unixrecvuntil(unixsock s, void *buf, size_t len, const char *delims, size_t delimcount, int64_t deadline);</h6>

<p>Reads data from UNIX domain connection until either buffer is full or
a delimiter character is reached.</p>

<p>First argument is the socket to read from. Second parameter is pointer to
the buffer to read the data to. Third argument is the size of the buffer.</p>

<p><tt>delims</tt> parameter is a sequence of bytes any of which, if encountered
in the incoming data, will cause <tt>tcprecvuntil()</tt> to exit. Size of the
sequence, in bytes, is passed to the function in <tt>delimcount</tt> parameter.
</p>

<p>Finally, last parameter is <a href="#deadlines">deadline</a> for the
operation.</p>

<p>For example, following example reads data until either comma or newline
character is encountered:</p>

<pre>
char buf[256];
size_t nbytes = unixrecvuntil(s, buf, sizeof(buf), ",\n", 2, -1);
</pre>

<p>In the case of success, <tt>errno</tt> is set to zero. In the case of failure
it is set to one of the following values:</p>

<ul style="list-style: none;">
  <li><tt>ECONNRESET</tt>: A connection was forcibly closed by a peer.</li>
  <li><tt>EIO</tt>: An I/O error occurred.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>ENOBUFS</tt>: Insufficient resources were available in the system to
      perform the operation.</li>
  <li><tt>ENOMEM</tt>: Insufficient memory was available to fulfill the
      request.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline exceeded.</li>
</ul>

<p>The function returns number of bytes received including the delimiter
character.</p>

<h6 id="unixsend">size_t unixsend(unixsock s, const void *buf, size_t len, int64_t deadline);</h6>

<p>Sends data to UNIX domain connection.</p>

<p>First argument is the socket handle to send the data to. Second argument is
pointer to the buffer to send. Third argument is the size of the buffer,
in bytes. Finally, fourth argument is the
<tt><a href="#deadlines">deadline</a></tt>.</p>

<pre>
size_t nbytes = unixsend(s, "ABC", 3, -1);
</pre>

<p>In the case of success, <tt>errno</tt> is set to zero. In the case of
failure it is set to one of the following error codes:</p>

<ul style="list-style: none;">
  <li><tt>ECONNRESET</tt>: A connection was forcibly closed by a peer.</li>
  <li><tt>EINTR</tt>: The function was interrupted by a signal.</li>
  <li><tt>EPIPE</tt>: The socket is shut down for writing.</li>
  <li><tt>EACCES</tt>: The process does not have appropriate privileges.</li>
  <li><tt>EIO</tt>: An I/O error occurred while reading from or writing to the
      file system.</li>
  <li><tt>ENOBUFS</tt>: No buffer space is available.</li>
  <li><tt>ETIMEDOUT</tt>: Deadline was reached.</li>
</ul>

<p>Whether successful or not, the function returns number of bytes actually
written to the socket.</p>

<p>To optimise the throughput <tt>unixsend()</tt> may store the data into output
buffer and not flush it to the peer immediately. To force sending of the
data use <tt><a href="#unixflush">unixflush()</a></tt> function.</p>

<h6 id="yield">void yield(void);</h6>

<p>By calling this function you give other coroutines a chance to run.</p>

<p>You should consider using <tt>yield()</tt> when doing lengthy computations
which don't involve natural coroutine switching points such as network
operations.</p>

<p>The function has no return value, nor can it return an error.</p>

</body>
</html>

