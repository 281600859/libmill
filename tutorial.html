<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>libmill</title>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>

<img src="libmill.png"/>

<p><b>Go-style concurrency in C</b></p>

<ul id='toplist'>
<li><a href="index.html">Home</a></li>
<li><a href="download.html">Download</a></li>
<li><a href="documentation.html">Documentation</a></li>
<li><a href="development.html">Development</a></li>
<li><a href="community.html">Community</a></li>
</ul>

<h2>Tutorial</h2>

<ul id="toc">
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#step1">Step 1: Setting up the stage</a></li>
  <li><a href="#step2">Step 2: The business logic</a></li>
  <li><a href="#step3">Step 3: Making it robust</a></li>
  <li><a href="#step4">Step 4: Making it parallel</a></li>
  <li><a href="#step5">Step 5: Deadlines</a></li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>In this tutorial you will develop a simple TCP "greet" server. The client
is meant to connect to it via telnet. After doing so, the server will ask
for their name, reply with a greeting and close the connection.</p>

<p>An interaction with our server will look like this:</p>

<pre>
$ telnet 127.0.0.1 5555
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
What's your name?
Bartholomaeus
Hello, Bartholomaeus!
Connection closed by foreign host.
</pre>

<p>In the process you will learn how to use coroutines, channels and the TCP
library.</p>

<h3 id="step1">Step 1: Setting up the stage</h3>

<p>First, include libmill's header file. Later on you will want some
functionality from the standard library, so include those headers as well:</p>

<pre>
#include &lt;libmill.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</pre>

<p>Add the <tt>main</tt> function. We'll assume, that the first argument,
if present, will be the port number to be used by the server. If not specified,
we will default to 5555:</p>

<pre>
int main(int argc, char *argv[]) {
    int port = 5555;
    if(argc &gt; 1)
        port = atoi(argv[1]);

    return 0;
}
</pre>

<p>Now we can start doing the actual interesting stuff.</p>

<p>Libmill's <tt>tcplisten()</tt> function can be used to create listening
TCP socket. The socket will be used to accept new TCP connections from the
clients:</p>

<pre>
tcpsock ls = tcplisten(NULL, port);
if(!ls) {
    perror("Can't open listening socket");
    return 1;
}
</pre>

<p>First argument to the function can be used to specify local network interface
to bind to. This is an advanced functionality and you likely won't need it.
Conveniently, you can just ignore it and set the argument to <tt>NULL</tt>.
The server will then bind to all available local network interfaces.</p>

<p>The second argument is, unsurprisingly, the port that the clients will
connect to. When testing the program keep in mind that the range of valid port
numbers is 1 to 65535 and binding to the ports from 1 to 1023 typically requires
superuser privileges.</p>

<p>If <tt>tcplisten()</tt> fails it returns NULL and sets <tt>errno</tt> to
appropriate error code. Libmill's TCP functions are in this respect very similar
to standard POSIX APIs. What it means is that we can use standard POSIX
mechanims -- <tt>perror()</tt> in this case -- to deal with errors.</p>

<p>If you run the program at this stage you'll find out that it finishes
immediately rather than pausing and waiting for a connection from the client
to arrive. That is what <tt>tcpaccept()</tt> function is for:

<pre>
tcpsock as = tcpaccept(ls, -1);
</pre>

<p>The function returns the newly established connection.</p>

<p>The second argument of the function is a deadline. We'll cover the
deadlines later on in this tutorial. For now, remember that constant -1 can
be used to mean 'no deadline' -- if there is no incoming connection
the call will block forever.</p>

<p>Finally, we want to handle many connections from the clients rather than
a single one so we put the <tt>tcpaccept()</tt> call into an infinite loop.</p>

<p>For now we'll just print a message when new connection is established
and close it immediately:</p>

<pre>
while(1) {
    tcpsock as = tcpaccept(ls, -1);
    printf("New connection!\n");
    tcpclose(as);
}
</pre>

<p>The source code for this step can be found in <tt>tutotial/step1.c</tt>.
All the following steps will be available in the same directory.</p>

<p>Build it like this:</p>

<pre>
$ gcc -o greetserver step1.c -lmill
</pre>

<p>Then run the resulting executable:</p>

<pre>
$ ./greetserver
</pre>

<p>The server now waits for a new connection. Establish one from a different
terminal using telnet and check whether it works like expected:</p>

<pre>
$ telnet 127.0.0.1 5555
</pre>

<p>To test whether error hadling works all right try to use invalid port
number:</p>

<pre>
$ ./greetserver 70000
Can't open listening socket: Invalid argument
$
</pre>

<p>Yay! Everyting seems to work as expected. Let's now move to the step 2.</p>

<h3 id="step2">Step 2: The business logic</h3>

<p>When new connection arrives, the first thing that we want to do is to send
the "What's your name?" question to the client:</p>

<pre>
tcpsend(as, "What's your name?\r\n", 19, -1);
tcpflush(as, -1);
</pre>

<p>First, note that <tt>tcpsend()</tt> works with bytes, not strings,
very much like POSIX <tt>send()</tt>. Zero is a perfectly valid byte to send
and thus we can't use it as a termination marker in the outgoing buffer.
Instead we have to specify the size of the buffer explicitly (19).</pp>

<p>Also note how the sending is done in two steps. The reason for that is that
libmill is designed for extremely high performance and thus it tries to
minimise the number of calls to the operating system. <tt>tcpsend()</tt>
function stores the data in user space and <tt>tcpflush()</tt> pushes it to the
kernel. That way, you can compose the message using many small, fast
<tt>tcpsend()</tt> calls and then flush it to the network using a single system
call.</p>

<pre>
char inbuf[256];
size_t sz = tcprecvuntil(as, inbuf, sizeof(inbuf), '\r', -1);
</pre>

<p>This piece of code simply reads the reply from the client until it
encounters a carriage return character ('\r') which is used,
in combination with a newline ('\n'), by telnet to terminate individual
lines.</p>

<p>Network protocols tend use size-prefixed fields, for example, integer 12,
followed by "Hello, world!" string. In such cases, <tt>tcprecv()</tt> function
does a good job.</tt>

<p>Other protocols though, mostly the text-based ones, rely on delimiters to
separate the fields. In such case "Hello, world!" string would be sent first,
followed by a newline to indicate that the string ends. Here,
<tt>tcprecvuntil()</tt> function does a better job  as it allows you to specify
the character upon receiving which it will stop receiving further.</p>

<p>Finally, keep in mind that both sending and receiving TCP functions return
the number of characters sent or received.</p>

<p>Having received the reply from the client, we can now construct the greeting
and send it to the client. The analysis of this code is left as an exercise to
the reader:</p>

<pre>
inbuf[sz - 1] = 0;
char outbuf[256];
int rc = snprintf(outbuf, sizeof(outbuf), "Hello, %s!\n", inbuf);

tcpsend(as, outbuf, rc, -1);
tcpflush(as, -1);
</pre>

<p>Compile the program and check whether it works like expected!</p>

<h3 id="step3">Step 3: Making it robust</h3>

<p>Now that the program does what it is supposed to let's make it work in
actual real-world-like environment.</p>

<p>Specifically, we don't want the client to be able to crash the server, so we
have to handle the errors from TCP functions. </p>

<p>The functions related to sending and receiving report the errors in a bit
different way. They return the number of bytes sent or received (as already seen
in the previous step) and at the same time they set the <tt>errno</tt> to
indicate success or failure.</p>

<p>Imagine the case where we are reading data from a TCP connection. We want
4 bytes. The peer sends 4 bytes and closes the connection. <tt>tcprecv()</tt>
function returns the size of received buffer (4) but sets <tt>errno</tt> to
<tt>ECONNRESET</tt> to indicate that the connection was closed. If there's no
error <tt>errno</tt> is set to zero.<p>

<p>In our program we'll handle the errors silently, by jumping to the cleanup
code (<tt>tcpclose(as)</tt>):</p>

<pre>
while(1) {
    tcpsock as = tcpaccept(ls, -1);

    tcpsend(as, "What's your name?\r\n", 19, -1);
    if(errno != 0)
        goto cleanup;

    ...

    cleanup:
    tcpclose(as);
}
</pre>

<p>We should also handle errors from <tt>tcpaccept()</tt>. Given that in such
case there's no connection established yet, we'll just retry instead
of jumping to the cleanup code:</p>

<pre>
tcpsock as = tcpaccept(ls, -1);
if(!as)
    continue;
</pre>

<h3 id="step4">Step 4: Making it parallel</h3>

<p>At this point the client can't crash the server, but it can block it.
Do the following experiment:</p>

<ol>
    <li>Start the server.</li>
    <li>From a different terminal start a telnet session and let it hang
        without entering your name.</li>
    <li>From yet different terminal open a new telnet session.</li>
    <li>Observe that the second session hangs without even asking you for your
        name.</li>
</ol>

<p>The reason for the behaviour is that the program doesn't even start accepting
new connection until the entire dialogue with the client is finished. What we
want instead is running any number of dialogues with the clients in parallel.
And that is where coroutines kick in.</p>

<p>Coroutines are very much like threads. They are very lightweight though.
Measuring on a modern hardware you can run up to something like twenty million
coroutines per second.</p>

<p>Coroutines are launched using <tt>go()</tt> construct.</p>

<p> In our case we can move the code performing the dialogue with the client
into a separate function and launch it as a coroutine:</p>

<pre>
void dialogue(tcpsock as) {
    tcpsend(as, "What's your name?\r\n", 19, -1);

    ...

    tcpclose(as);
}

int main(int argc, char *argv[]) {

    ...

    while(1) {
        tcpsock as = tcpaccept(ls, -1);
        if(!as)
            continue;
        go(dialogue(as));
    }
}
</pre>

<p>Let's compile it and try to initial experiment once again. As can be seen,
one client now cannot block another one. Great. Let's move on.</p>

<h3 id="step5">Step 5: Deadlines</h3>

<p>File descriptors can be a scarce resource. If a client connects to
greetserver and lets the dialogue hang without entering the name, one file
descriptor on the server side is, for all practical purposes, wasted.</p>

<p>To deal with the problem we are going to timeout the whole client/server
dialogue. If it takes more than 10 seconds, server will kill the connection
straight away.</p>

<p>One thing to note is that libmill uses deadlines rather than more
conventional timeouts. In other words, you specify the time instant when
you want the operation to finish rather than maximum time it should take to
run. To construct deadlines easily, libmill provides <tt>now()</tt> function.
The deadline is expressed in milliseconds so you can create a deadline
10 seconds in the future like this:</p>

<pre>
int64_t deadline = now() + 10000;
</pre>

<p>Further, you have to modify all the potentially blocking function calls in
the program to take the deadline parameter. For example:</p>

<pre>
tcpsend(as, "What's your name?\r\n", 19, deadline);
if(errno != 0)
    goto cleanup;
tcpflush(as, deadline);
if(errno != 0)
    goto cleanup;
</pre>

<p>Note that <tt>errno</tt> is set to <tt>ETIMEDOUT</tt> in case the deadline
is reached. However, we treat all the errors in the same way (by closing the
connection) and thus we don't have to do any specific provisions for the
deadline case.</p>

</body>
</html>

