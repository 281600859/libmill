/* Wed Jul 09 01:00:43 +0200 2014:
   This file was generated by mill from stdmill.mc */

#include "mill.h"

#include "stdmill.h"

/******************************************************************************/
/* Generic helpers.                                                           */
/******************************************************************************/

#define mill_cont(ptr, type, member) \
    (ptr ? ((type*) (((char*) ptr) - offsetof(type, member))) : NULL)

#define uv_assert(x)\
    do {\
        if (x < 0) {\
            fprintf (stderr, "%s: %s (%s:%d)\n", uv_err_name (x),\
                uv_strerror (x), __FILE__, __LINE__);\
            fflush (stderr);\
            abort ();\
        }\
    } while (0)

/******************************************************************************/
/* msleep                                                                     */
/******************************************************************************/

static void msleep_timer_cb (
    uv_timer_t *timer);
static void msleep_close_cb (
    uv_handle_t *handle);

struct mill_cf_msleep {

    /* Generic coframe header. */
    struct mill_cfh mill_cfh;

    /* Coroutine arguments. */
    int rc;
    int milliseconds;

    /* Local variables. */
    uv_timer_t timer;
    void * hndl;

    /* Destinations for out arguments. */
    int *mill_out_rc;
};

static void mill_handler_msleep (void *cfptr, void *event)
{
    mill_handlerimpl_prologue (msleep);

    switch (cf->mill_cfh.pc) {
    case 0:
        break;
    case 1:
        goto mill_pc_1;
    case 2:
        goto mill_pc_2;
    case 3:
        goto mill_pc_3;
    default:
        assert (0);
    }

    /* Start the timer. */
    (cf->rc) = uv_timer_init (&cf->mill_cfh.loop->uv_loop, &(cf->timer));
    uv_assert ((cf->rc));
    (cf->rc) = uv_timer_start (&(cf->timer), msleep_timer_cb, (cf->milliseconds), 0);
    uv_assert ((cf->rc));
    
    /* Wait till it finishes or the coroutine is canceled. */
    mill_wait (1, &(cf->hndl));
    if ((cf->hndl) == msleep_timer_cb)
        (cf->rc) = 0;
    else if ((cf->hndl) == 0)
        (cf->rc) = ECANCELED;
    else
        assert (0);
    
    /* Close the timer. Ignore cancel requests during this phase. */
    uv_close ((uv_handle_t*) &(cf->timer), msleep_close_cb);
    while (1) {
        mill_wait (2, &(cf->hndl));
        if ((cf->hndl) == msleep_close_cb)
           break;
        assert ((cf->hndl) == 0);
    }

    mill_handlerimpl_epilogue (msleep, 3);
}

static void mill_output_msleep (void *cfptr)
{
    struct mill_cf_msleep *cf;

    cf = (struct mill_cf_msleep*) cfptr;    
    *cf->mill_out_rc = cf->rc;
}

const struct mill_type mill_type_msleep = {
    mill_type_tag,
    mill_handler_msleep,
    mill_output_msleep,
    "msleep"
};

void *mill_call_msleep (
    void *cfptr,
    const struct mill_type *type,
    struct mill_loop *loop,
    void *parent,
    int *rc,
    int milliseconds)
{
    mill_callimpl_prologue (msleep);
    cf->mill_out_rc = rc;
    cf->milliseconds = milliseconds;
    mill_callimpl_epilogue (msleep);
}

void msleep (
    int *rc, 
    int milliseconds)
{
    mill_synccallimpl_prologue (msleep);
    mill_call_msleep (&cf, &mill_type_msleep, &loop, 0, rc, milliseconds);
    mill_synccallimpl_epilogue (msleep);
}

static void msleep_timer_cb (
    uv_timer_t *timer)
{
    struct mill_cf_msleep *cf;

    cf = mill_cont (timer, struct mill_cf_msleep, timer);
    mill_handler_msleep (cf, (void*) msleep_timer_cb);
}

static void msleep_close_cb (
    uv_handle_t *handle)
{
    struct mill_cf_msleep *cf;

    cf = mill_cont (handle, struct mill_cf_msleep, timer);
    mill_handler_msleep (cf, (void*) msleep_close_cb);
}

/******************************************************************************/
/* tcpsocket                                                                  */
/******************************************************************************/

/* For the definition of struct tcpsocket look into stdmillx.h header file. */

static void tcpsocket_close_cb (
    uv_handle_t* handle);
static void tcpsocket_listen_cb (
    uv_stream_t *s,
    int status);
static void tcpsocket_connect_cb (
    uv_connect_t* req,
    int status);
static void tcpsocket_send_cb (
    uv_write_t* req,
    int status);
static void tcpsocket_alloc_cb (
    uv_handle_t* handle,
    size_t suggested_size,
    uv_buf_t* buf);
static void tcpsocket_recv_cb (
    uv_stream_t* stream,
    ssize_t nread,
    const uv_buf_t* buf);

int tcpsocket_init (
    struct tcpsocket *self,
    struct mill_loop *loop)
{
    self->loop = &loop->uv_loop;
    self->pc = 0;
    self->recvcfptr = 0;
    self->sendcfptr = 0;
    return uv_tcp_init (&loop->uv_loop, &self->s);
}

struct mill_cf_tcpsocket_term {

    /* Generic coframe header. */
    struct mill_cfh mill_cfh;

    /* Coroutine arguments. */
    struct tcpsocket * self;

    /* Local variables. */
    void * hndl;
};

static void mill_handler_tcpsocket_term (void *cfptr, void *event)
{
    mill_handlerimpl_prologue (tcpsocket_term);

    switch (cf->mill_cfh.pc) {
    case 0:
        break;
    case 1:
        goto mill_pc_1;
    case 2:
        goto mill_pc_2;
    default:
        assert (0);
    }

    /* Initiate the termination. */
    (cf->self)->recvcfptr = cf;
    uv_close ((uv_handle_t*) &(cf->self)->s, tcpsocket_close_cb);
    
    /* Wait till socket is closed. In the meanime ignore cancel requests. */
    while (1) {
        mill_wait (1, &(cf->hndl));
        if ((cf->hndl) == tcpsocket_close_cb)
           break;
        assert ((cf->hndl) == 0);
    }

    mill_handlerimpl_epilogue (tcpsocket_term, 2);
}

static void mill_output_tcpsocket_term (void *cfptr)
{
    struct mill_cf_tcpsocket_term *cf;

    cf = (struct mill_cf_tcpsocket_term*) cfptr;    
}

const struct mill_type mill_type_tcpsocket_term = {
    mill_type_tag,
    mill_handler_tcpsocket_term,
    mill_output_tcpsocket_term,
    "tcpsocket_term"
};

void *mill_call_tcpsocket_term (
    void *cfptr,
    const struct mill_type *type,
    struct mill_loop *loop,
    void *parent,
    struct tcpsocket * self)
{
    mill_callimpl_prologue (tcpsocket_term);
    cf->self = self;
    mill_callimpl_epilogue (tcpsocket_term);
}

void tcpsocket_term (
    struct tcpsocket * self)
{
    mill_synccallimpl_prologue (tcpsocket_term);
    mill_call_tcpsocket_term (&cf, &mill_type_tcpsocket_term, &loop, 0, self);
    mill_synccallimpl_epilogue (tcpsocket_term);
}

int tcpsocket_bind (
    struct tcpsocket *self,
    struct sockaddr *addr,
    int flags)
{
    return uv_tcp_bind (&self->s, addr, flags);
}

int tcpsocket_listen (
    struct tcpsocket *self,
    int backlog)
{
    return uv_listen ((uv_stream_t*) &self->s, backlog, tcpsocket_listen_cb);
}

struct mill_cf_tcpsocket_connect {

    /* Generic coframe header. */
    struct mill_cfh mill_cfh;

    /* Coroutine arguments. */
    int rc;
    struct tcpsocket * self;
    struct sockaddr * addr;

    /* Local variables. */
    uv_connect_t req;
    void * hndl;

    /* Destinations for out arguments. */
    int *mill_out_rc;
};

static void mill_handler_tcpsocket_connect (void *cfptr, void *event)
{
    mill_handlerimpl_prologue (tcpsocket_connect);

    switch (cf->mill_cfh.pc) {
    case 0:
        break;
    case 1:
        goto mill_pc_1;
    case 2:
        goto mill_pc_2;
    default:
        assert (0);
    }

    /* Start connecting. */
    (cf->self)->recvcfptr = cf;
    (cf->rc) = uv_tcp_connect (&(cf->req), &(cf->self)->s, (cf->addr), tcpsocket_connect_cb);
    if ((cf->rc) != 0)
        goto mill_finally;
    
    /* Wait till connecting finishes. */
    mill_wait (1, &(cf->hndl));
    
    /* TODO: Canceling connect operation requires closing the entire socket. */
    if (!(cf->hndl)) {
        assert (0);
    }
    
    assert ((cf->hndl) == tcpsocket_connect_cb);

    mill_handlerimpl_epilogue (tcpsocket_connect, 2);
}

static void mill_output_tcpsocket_connect (void *cfptr)
{
    struct mill_cf_tcpsocket_connect *cf;

    cf = (struct mill_cf_tcpsocket_connect*) cfptr;    
    *cf->mill_out_rc = cf->rc;
}

const struct mill_type mill_type_tcpsocket_connect = {
    mill_type_tag,
    mill_handler_tcpsocket_connect,
    mill_output_tcpsocket_connect,
    "tcpsocket_connect"
};

void *mill_call_tcpsocket_connect (
    void *cfptr,
    const struct mill_type *type,
    struct mill_loop *loop,
    void *parent,
    int *rc,
    struct tcpsocket * self,
    struct sockaddr * addr)
{
    mill_callimpl_prologue (tcpsocket_connect);
    cf->mill_out_rc = rc;
    cf->self = self;
    cf->addr = addr;
    mill_callimpl_epilogue (tcpsocket_connect);
}

void tcpsocket_connect (
    int *rc, 
    struct tcpsocket * self, 
    struct sockaddr * addr)
{
    mill_synccallimpl_prologue (tcpsocket_connect);
    mill_call_tcpsocket_connect (&cf, &mill_type_tcpsocket_connect, &loop, 0, rc, self, addr);
    mill_synccallimpl_epilogue (tcpsocket_connect);
}

struct mill_cf_tcpsocket_accept {

    /* Generic coframe header. */
    struct mill_cfh mill_cfh;

    /* Coroutine arguments. */
    int rc;
    struct tcpsocket * self;
    struct tcpsocket * newsock;

    /* Local variables. */
    void * hndl;

    /* Destinations for out arguments. */
    int *mill_out_rc;
};

static void mill_handler_tcpsocket_accept (void *cfptr, void *event)
{
    mill_handlerimpl_prologue (tcpsocket_accept);

    switch (cf->mill_cfh.pc) {
    case 0:
        break;
    case 1:
        goto mill_pc_1;
    case 2:
        goto mill_pc_2;
    default:
        assert (0);
    }

    /* Link the lisening socket with the accepting socket. */
    (cf->self)->recvcfptr = cf;
    
    /* Wait for an incoming connection. */
    mill_wait (1, &(cf->hndl));
    if (!(cf->hndl)) {
        (cf->rc) = ECANCELED;
        goto mill_finally;
    }
    
    /* There's a new incoming connection. Let's accept it. */
    assert ((cf->hndl) == tcpsocket_listen_cb);
    (cf->rc) = uv_accept ((uv_stream_t*) &(cf->self)->s, (uv_stream_t*) &(cf->newsock)->s);

    mill_handlerimpl_epilogue (tcpsocket_accept, 2);
}

static void mill_output_tcpsocket_accept (void *cfptr)
{
    struct mill_cf_tcpsocket_accept *cf;

    cf = (struct mill_cf_tcpsocket_accept*) cfptr;    
    *cf->mill_out_rc = cf->rc;
}

const struct mill_type mill_type_tcpsocket_accept = {
    mill_type_tag,
    mill_handler_tcpsocket_accept,
    mill_output_tcpsocket_accept,
    "tcpsocket_accept"
};

void *mill_call_tcpsocket_accept (
    void *cfptr,
    const struct mill_type *type,
    struct mill_loop *loop,
    void *parent,
    int *rc,
    struct tcpsocket * self,
    struct tcpsocket * newsock)
{
    mill_callimpl_prologue (tcpsocket_accept);
    cf->mill_out_rc = rc;
    cf->self = self;
    cf->newsock = newsock;
    mill_callimpl_epilogue (tcpsocket_accept);
}

void tcpsocket_accept (
    int *rc, 
    struct tcpsocket * self, 
    struct tcpsocket * newsock)
{
    mill_synccallimpl_prologue (tcpsocket_accept);
    mill_call_tcpsocket_accept (&cf, &mill_type_tcpsocket_accept, &loop, 0, rc, self, newsock);
    mill_synccallimpl_epilogue (tcpsocket_accept);
}

struct mill_cf_tcpsocket_send {

    /* Generic coframe header. */
    struct mill_cfh mill_cfh;

    /* Coroutine arguments. */
    int rc;
    struct tcpsocket * self;
    const void * buf;
    size_t len;

    /* Local variables. */
    uv_write_t req;
    uv_buf_t buffer;
    void * hndl;

    /* Destinations for out arguments. */
    int *mill_out_rc;
};

static void mill_handler_tcpsocket_send (void *cfptr, void *event)
{
    mill_handlerimpl_prologue (tcpsocket_send);

    switch (cf->mill_cfh.pc) {
    case 0:
        break;
    case 1:
        goto mill_pc_1;
    case 2:
        goto mill_pc_2;
    default:
        assert (0);
    }

    /* Start the send operation. */
    (cf->buffer).base = (void*) (cf->buf);
    (cf->buffer).len = (cf->len);
    (cf->rc) = uv_write (&(cf->req), (uv_stream_t*) &(cf->self)->s, &(cf->buffer), 1,
        tcpsocket_send_cb);
    if ((cf->rc) != 0)
        goto mill_finally;
    
    /* Mark the socket as being in process of sending. */
    (cf->self)->sendcfptr = cf;
    
    /* Wait till sending is done. */
    mill_wait (1, &(cf->hndl));
    
    /* TODO: Cancelling a send operation requires closing the entire socket. */
    if (!(cf->hndl)) {
        assert (0);
    }
    
    assert ((cf->hndl) == tcpsocket_send_cb);
    (cf->self)->sendcfptr = 0;
    (cf->rc) = 0;

    mill_handlerimpl_epilogue (tcpsocket_send, 2);
}

static void mill_output_tcpsocket_send (void *cfptr)
{
    struct mill_cf_tcpsocket_send *cf;

    cf = (struct mill_cf_tcpsocket_send*) cfptr;    
    *cf->mill_out_rc = cf->rc;
}

const struct mill_type mill_type_tcpsocket_send = {
    mill_type_tag,
    mill_handler_tcpsocket_send,
    mill_output_tcpsocket_send,
    "tcpsocket_send"
};

void *mill_call_tcpsocket_send (
    void *cfptr,
    const struct mill_type *type,
    struct mill_loop *loop,
    void *parent,
    int *rc,
    struct tcpsocket * self,
    const void * buf,
    size_t len)
{
    mill_callimpl_prologue (tcpsocket_send);
    cf->mill_out_rc = rc;
    cf->self = self;
    cf->buf = buf;
    cf->len = len;
    mill_callimpl_epilogue (tcpsocket_send);
}

void tcpsocket_send (
    int *rc, 
    struct tcpsocket * self, 
    const void * buf, 
    size_t len)
{
    mill_synccallimpl_prologue (tcpsocket_send);
    mill_call_tcpsocket_send (&cf, &mill_type_tcpsocket_send, &loop, 0, rc, self, buf, len);
    mill_synccallimpl_epilogue (tcpsocket_send);
}

struct mill_cf_tcpsocket_recv {

    /* Generic coframe header. */
    struct mill_cfh mill_cfh;

    /* Coroutine arguments. */
    int rc;
    struct tcpsocket * self;
    void * buf;
    size_t len;

    /* Local variables. */
    void * hndl;

    /* Destinations for out arguments. */
    int *mill_out_rc;
};

static void mill_handler_tcpsocket_recv (void *cfptr, void *event)
{
    mill_handlerimpl_prologue (tcpsocket_recv);

    switch (cf->mill_cfh.pc) {
    case 0:
        break;
    case 1:
        goto mill_pc_1;
    case 2:
        goto mill_pc_2;
    default:
        assert (0);
    }

    /* Sart the receiving. */
    (cf->rc) = uv_read_start ((uv_stream_t*) &(cf->self)->s,
        tcpsocket_alloc_cb, tcpsocket_recv_cb);
    if ((cf->rc) != 0)
        goto mill_finally;
    
    /* Mark the socket as being in process of receiving. */
    cf->self->recvcfptr = cf;
    
    while (1) {
    
        /* Wait for next chunk of data. */
        mill_wait (1, &(cf->hndl));
    
        /* User asks operation to be canceled. */
        if (!(cf->hndl)) {
            uv_read_stop ((uv_stream_t*) &(cf->self)->s);
            (cf->self)->recvcfptr = 0;
            (cf->rc) = ECANCELED;
            goto mill_finally;
        }
    
        /* If there are no more data to be read, stop reading. */
        if (!(cf->len)) {
            uv_read_stop ((uv_stream_t*) &(cf->self)->s);
            (cf->self)->recvcfptr = 0;
            (cf->rc) = 0;
            break;
        }
    }

    mill_handlerimpl_epilogue (tcpsocket_recv, 2);
}

static void mill_output_tcpsocket_recv (void *cfptr)
{
    struct mill_cf_tcpsocket_recv *cf;

    cf = (struct mill_cf_tcpsocket_recv*) cfptr;    
    *cf->mill_out_rc = cf->rc;
}

const struct mill_type mill_type_tcpsocket_recv = {
    mill_type_tag,
    mill_handler_tcpsocket_recv,
    mill_output_tcpsocket_recv,
    "tcpsocket_recv"
};

void *mill_call_tcpsocket_recv (
    void *cfptr,
    const struct mill_type *type,
    struct mill_loop *loop,
    void *parent,
    int *rc,
    struct tcpsocket * self,
    void * buf,
    size_t len)
{
    mill_callimpl_prologue (tcpsocket_recv);
    cf->mill_out_rc = rc;
    cf->self = self;
    cf->buf = buf;
    cf->len = len;
    mill_callimpl_epilogue (tcpsocket_recv);
}

void tcpsocket_recv (
    int *rc, 
    struct tcpsocket * self, 
    void * buf, 
    size_t len)
{
    mill_synccallimpl_prologue (tcpsocket_recv);
    mill_call_tcpsocket_recv (&cf, &mill_type_tcpsocket_recv, &loop, 0, rc, self, buf, len);
    mill_synccallimpl_epilogue (tcpsocket_recv);
}

static void tcpsocket_close_cb (
    uv_handle_t* handle)
{
    struct tcpsocket *self;
    struct mill_cf_tcpsocket_term *cf;

    self = mill_cont (handle, struct tcpsocket, s);
    cf = (struct mill_cf_tcpsocket_term*) self->recvcfptr;
    mill_handler_tcpsocket_term (cf, (void*) tcpsocket_close_cb);
}

static void tcpsocket_listen_cb (
    uv_stream_t *s,
    int status)
{
    struct tcpsocket *self;
    struct mill_cf_tcpsocket_accept *cf;

    self = mill_cont (s, struct tcpsocket, s);

    /* If nobody is accepting, close the incoming connection. */
    if (!self->recvcfptr) {
        assert (0);
    }

    /* If somebody is accepting, move the accept coroutine on. */
    cf = (struct mill_cf_tcpsocket_accept*) self->recvcfptr;
    mill_handler_tcpsocket_accept (cf, (void*) tcpsocket_listen_cb);
}

static void tcpsocket_connect_cb (
    uv_connect_t* req,
    int status)
{
    struct mill_cf_tcpsocket_connect *cf;

    cf = mill_cont (req, struct mill_cf_tcpsocket_connect, req);
    mill_handler_tcpsocket_connect (cf, (void*) tcpsocket_connect_cb);
}

static void tcpsocket_send_cb (
    uv_write_t* req,
    int status)
{
    struct mill_cf_tcpsocket_send *cf;

    cf = mill_cont (req, struct mill_cf_tcpsocket_send, req);
    mill_handler_tcpsocket_send (cf, (void*) tcpsocket_send_cb);
}

static void tcpsocket_alloc_cb (
    uv_handle_t* handle,
    size_t suggested_size,
    uv_buf_t* buf)
{
    struct tcpsocket *self;
    struct mill_cf_tcpsocket_recv *cf;

    self = mill_cont (handle, struct tcpsocket, s);
    assert (self->recvcfptr);
    cf = (struct mill_cf_tcpsocket_recv*) self->recvcfptr;

    buf->base = cf->buf;
    buf->len = cf->len;
}

static void tcpsocket_recv_cb (
    uv_stream_t* stream,
    ssize_t nread,
    const uv_buf_t* buf)
{
    struct tcpsocket *self;
    struct mill_cf_tcpsocket_recv *cf;

    self = mill_cont (stream, struct tcpsocket, s);
    assert (self->recvcfptr);
    cf = (struct mill_cf_tcpsocket_recv*) self->recvcfptr;

    /* Adjust the input buffer to not cover the data already received. */
    assert (buf->base == cf->buf);
    assert (nread <= cf->len);
    cf->buf = ((char*) cf->buf) + nread;
    cf->len -= nread;

    mill_handler_tcpsocket_recv (cf, (void*) tcpsocket_recv_cb);
}

